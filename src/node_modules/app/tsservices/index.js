function ts () {
	return window.ts;
}

const servicesHost = files => ({
	getScriptFileNames: () => Object.keys(files),
	getScriptVersion: () => "0",
	getScriptSnapshot: fileName => {
		if (fileName in files) {
			return ts().ScriptSnapshot.fromString(files[fileName]);
		}
		return undefined;
	},
	getCurrentDirectory: () => '/',
	getCompilationSettings: () => ({}),
	getDefaultLibFileName: () => 'lib.d.ts',
	fileExists: fileName => fileName in files,
	readFile: () => {
		throw new Error("readFile is not implemented");
	},
	readDirectory: () => []
});

const LIBDTS = `// Standard types
interface Date {}

type Record<K extends keyof any, T> = {
    [P in K]: T;
};
`;

function createLanguageServiceHost(FILENAME, source) {
	const files = [FILENAME];
	return {
		getScriptFileNames,
		getScriptVersion,
		getScriptSnapshot,
		getCurrentDirectory,
		getCompilationSettings,
		getDefaultLibFileName,
		fileExists,
		readFile,
		readDirectory
	};

	function getScriptFileNames() {
		return files;
	}
	function getScriptVersion(path) {
		return "0";
	}
	function getScriptSnapshot(fileName) {
		if (fileName === FILENAME) {
			return ts().ScriptSnapshot.fromString(source);
		}
		else if (fileName === 'lib.d.ts') {
			return ts().ScriptSnapshot.fromString(LIBDTS);
		}
		return undefined;
	}
	function getCurrentDirectory() {
		return '/';
	}
	function getCompilationSettings() {
		// typeRoots here is no-op:
		// We may need to implement resolveTypeReferenceDirectives?
		return {
		};
	}
	function getDefaultLibFileName(options) {
		return 'lib.d.ts';
	}
	function fileExists(path) {
		return path in files;
	}
	function readFile(path, encoding) {
		throw new Error("readFile is not implemented");
	}
	function readDirectory(
		path,
		extensions,
		exclude,
		include,
		depth
	) {
		return [];
	}
}

const FILENAME = 'source.ts';
export function getCompletions (
	source,
	position
) {
	// const host = servicesHost({[FILENAME]: source});
	const host = createLanguageServiceHost(FILENAME, source);
	const service = ts().createLanguageService(host, ts().createDocumentRegistry());
	const completions = service.getCompletionsAtPosition(FILENAME, position, {});
	return completions && completions.map(completionData => {
		const details = service.getCompletionEntryDetails(FILENAME, position, completionData.name);
		return {
			name: completionData.name,
			displayText: details.displayParts.map(part => part.text).join('')
		};
	})
}
