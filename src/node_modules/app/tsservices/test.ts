import * as ts from "typescript";
import {src} from './testsrc';


const LIBDTS = `// Standard types
interface Date {}

type Record<K extends keyof any, T> = {
    [P in K]: T;
};
`;

const srcname = "mysrc.ts";

const host = createLanguageServiceHost(srcname, src);
const service = ts.createLanguageService(host, ts.createDocumentRegistry());
const semDiags = service.getSemanticDiagnostics(srcname);
console.log(semDiags);
const synDiags = service.getSyntacticDiagnostics(srcname);
console.log(synDiags);


const position = src.lastIndexOf('{') + 1;
for (let p = position-20; p < src.length; p++) {
	try {
		console.log(src.slice(src.slice(0,p).lastIndexOf('\n'), p));
		const info = service.getCompletionsAtPosition(srcname, p, {
			//includeCompletionsWithInsertText: true,
			//includeInsertTextCompletions: true,
			//includeExternalModuleExports: true,
			//includeAutomaticOptionalChainCompletions: true
		});
		//console.log(info && info.entries.map(i => i.name).join(', '));
		console.log(info && info.entries.map(i => {

			const details = service.getCompletionEntryDetails(srcname, p, i.name, undefined, undefined, undefined);
			const displayText = details.displayParts.map(i => i.text).join('');
			return `${details.name} -> ${displayText}`;
		}));
		//console.log(info && info.entries);
	}
	catch (e) {
		console.log(e);
	}
}

function createLanguageServiceHost(name, source): ts.LanguageServiceHost {
	const files = [name];
	return {
		getScriptFileNames,
		getScriptVersion,
		getScriptSnapshot,
		getCurrentDirectory,
		getCompilationSettings,
		getDefaultLibFileName,
		fileExists,
		readFile,
		readDirectory
	};

	function getScriptFileNames() {
		return files;
	}
	function getScriptVersion(path: string) {
		return "0";
	}
	function getScriptSnapshot(fileName: string): ts.IScriptSnapshot {
		if (fileName === name) {
			return ts.ScriptSnapshot.fromString(source);
		}/*
		else if (fileName === 'lib.d.ts') {
			return ts.ScriptSnapshot.fromString(LIBDTS);
		}*/
		return undefined;
	}
	function getCurrentDirectory() {
		return '/';
	}
	function getCompilationSettings(): ts.CompilerOptions {
		// typeRoots here is no-op:
		// We may need to implement resolveTypeReferenceDirectives?
		return {
		};
	}
	function getDefaultLibFileName(options: ts.CompilerOptions): string {
		return 'lib.d.ts';
	}
	function fileExists(path: string) {
		return path in files;
	}
	function readFile(path: string, encoding?: string): string {
		throw new Error("readFile is not implemented");
	}
	function readDirectory(
		path: string,
		extensions?: ReadonlyArray<string>,
		exclude?: ReadonlyArray<string>,
		include?: ReadonlyArray<string>,
		depth?: number
	): string[] {
		return [];
	}
}

export default service;