<script>
	// eslint-disable-next-line node/no-extraneous-import
	import areEqual from 'just-compare';
	// eslint-disable-next-line node/no-unpublished-import
	import { createEventDispatcher } from 'svelte';
	import IconHelpCircle from 'app/components/icons/IconHelpCircle.svelte';

	import { autoID } from 'app/utils';

	import BooleanRadios from './BooleanRadios.svelte';

	const dispatch = createEventDispatcher();

	const id = autoID();

	export let labelText = '';
	export let dataType = 'text';
	export let value;
	export let defaultValue;
	export let required;

	let type;
	let fieldValue;
	let placeholder;
	let currentValue = value;
	let isDefaultValue = false;

	const inputTypes = {
		date: 'date',
		'boolean': 'checkbox',
		'Opaque<Date, "date">': 'date',
		'Opaque<string, "Date_YYYYMMDD_dash">': 'date',
		'Opaque<string, "Date_YYYYMMDD_dash_time">': 'date',
		'Opaque<string, "ES_keyword">': 'text',
		'Opaque<string, "ES_text">': 'text',
		'Opaque<string, "ES_text_w_keyword">': 'text',
		'Opaque<number, "integer">': 'number',
		'Opaque<number, "float">': 'number',
		string: 'text'
	}

	function pad (num, size) {
		return `${num}`.padStart(size, '0');
	}

	function Date_YYYYMMDD_dash (date) {
		return `${date.getFullYear()}-${pad(date.getMonth() + 1, 2)}-${pad(date.getDate(), 2)}`;
	}

	function Date_YYYYMMDD_dash_time (date) {
		return `${Date_YYYYMMDD_dash(date)} ${pad(date.getHours(), 2)}:${pad(date.getMinutes(), 2)}:${pad(date.getSeconds(), 2)}`;
	}

	function incomingBoolean (incoming) {
		if (incoming === null || incoming === undefined) {
			return 'null';
		}
		return Boolean(incoming);
	}
	function outgoingBoolean (outgoing) {
		if (outgoing === 'null') {
			return null;
		}
		return outgoing;
	}

	const incomingFormatters = {
		'boolean': incomingBoolean,
		'Opaque<number, "integer">': v => v.toString(),
		'Opaque<number, "float">': v => v.toString(),
		'Opaque<string, "Date_YYYYMMDD_dash">': dateString =>
			Date_YYYYMMDD_dash(new Date(dateString)),
		'Opaque<string, "Date_YYYYMMDD_dash_time">': dateString =>
			Date_YYYYMMDD_dash(new Date(dateString)),
	}

	const outgoingFormatters = {
		'Opaque<string, "Date_YYYYMMDD_dash">': dateString =>
			Date_YYYYMMDD_dash(new Date(dateString)),
		'Opaque<string, "Date_YYYYMMDD_dash_time">': dateString =>
			Date_YYYYMMDD_dash_time(new Date(dateString)),
		'Opaque<number, "integer">': parseInt,
		'Opaque<number, "float">': parseFloat,
	}

	const placeholders = {
		'Opaque<number, "integer">': 'integer',
		'Opaque<number, "float">': 'float',
		'Opaque<string, "ES_keyword">': 'text',
		'Opaque<string, "ES_text">': 'text',
		'Opaque<string, "ES_text_w_keyword">': 'text',
	}

	function formatIncomingValue (incomingValue) {
		let result;
		switch (dataType) {
			case 'boolean':
				result = incomingBoolean(incomingValue);
				break;
			default:
				if (
					dataType in incomingFormatters
					&& incomingValue !== null
					&& incomingValue !== undefined
				) {
					result = incomingFormatters[dataType](incomingValue)
				}
				else if (dataType.startsWith('{')) {
					result = incomingValue ? JSON.stringify(incomingValue) : '';
				}
				else {
					result = incomingValue || '';
				}
		}
		return result;
	}

	function parseOutgoingValue (outgoingValue) {
		let outgoing = outgoingValue;
		if (dataType === 'boolean') {
			outgoing = outgoingBoolean(outgoingValue);
		}
		else if (dataType in outgoingFormatters) {
			outgoing = outgoing.length > 0
				? outgoingFormatters[dataType](outgoing)
				: null;
		}
		else if (dataType.startsWith('{')) {
			if (!outgoingValue) {
				outgoing = null;
			} else {
				try {
					outgoing = JSON.parse(outgoingValue);
				}
				catch (e) {
					console.log('Problem parsing JSON, aborting dispatch...', e);
					// return ;
				}
			}
		}
		return outgoing;
	}
	
	function notify (payload) {
		dispatch('change', parseOutgoingValue(payload));
	}

	function displayDocs () {
		dispatch('docs', 'display');
	}

	function hideDocs () {
		dispatch('docs', 'hide');
	}

	function handleFocus () {
		dispatch('docs', 'set');
	}

	function handleBlur () {
		dispatch('docs', 'unset');
	}

	function handleChange (event) {
		notify(event.target.value);
	}

	function handleInput (event) {
		currentValue = event.target.value;
		// TODO Perhaps we need to handle validation as well
	}

	function computePlaceHolder (newDataType) {
		if (newDataType in placeholders) {
			return placeholders[newDataType];
		}
		return newDataType;
	}

	function handleValueChange (newValue) {
		fieldValue = formatIncomingValue(newValue);
	}

	function handleFieldValueChange (newFieldValue) {
		currentValue = newFieldValue;
		if (dataType === 'boolean') {
			notify(newFieldValue);
		}
	}

	$: {
		console.log(dataType);
		placeholder = computePlaceHolder(dataType);
		type = inputTypes[dataType];
	}
	$: handleValueChange(value);
	$: handleFieldValueChange(fieldValue);
	$: isDefaultValue = areEqual(parseOutgoingValue(currentValue), defaultValue);
</script>

<label
	for={id}
	on:mouseover={displayDocs}
	on:mouseout={hideDocs}
>
	{labelText}
	<IconHelpCircle size={14} />
</label>
{#if dataType !== 'boolean'}
	<input {id} {type} value={fieldValue} 
		on:change={handleChange}
		on:input={handleInput}
		on:focus={handleFocus}
		on:blur={handleBlur}
		on:mouseover={displayDocs}
		on:mouseout={hideDocs}
		{placeholder}
		class:required
		class:empty={currentValue === ''}
		class:default={isDefaultValue}
	>
{:else if dataType === 'boolean'}
	<div
		on:mouseover={displayDocs}
		on:mouseout={hideDocs}
	>
		<BooleanRadios
			id={id}
			bind:value={fieldValue}
			{required}
			on:focus={handleFocus}
			on:blur={handleBlur}
			{defaultValue}
		/>
	</div>
{/if}

<style>
label {
	white-space: nowrap;
}
label:not(.boolean-state) {
	justify-self: end;
}
input:not([type='checkbox']):not([type='date']):not([type='radio']) {
	width: 100%;
}
.required.empty {
	border-color: red;
}
.default {
	background-color: #fedeff;
}
</style>
