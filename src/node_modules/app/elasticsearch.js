export const descriptionsEN = {
	avg: "Average",
	weighted_avg: "Weighted Average",
	cardinality: "Cardinality",
	extended_stats: "Extended Statistics",
	geo_bounds: "Geographic Bounds",
	geo_centroid: "Geographic Centroid",
	max: "Maximum",
	min: "Minimum",
	percentiles: "Percentiles",
	percentile_ranks: "Percentile Ranks",
	scripted_metric: "Scripted Metric",
	stats: "Statistics",
	string_stats: "String Statistics",
	sum: "Sum",
	top_tags: "Top Hits",
	value_count: "Value Count",
	median_absolute_deviation: "Median Absolute Deviation"
}

export const aggregationsPerType = {
	ES_geo_point_obj: [
		'cardinality',
		'geo_bounds',
		'geo_centroid',
		'value_count'
	],
	ES_keyword: [
		'value_count',
		// 'string_stats' //disabled until backend upgrade
	],
	boolean: [
		'cardinality',
		// 'percentile_ranks',
		'value_count'
	],
	integer: [
		'cardinality',
		'extended_stats',
		// 'percentile_ranks',
		'value_count'
	],
	Date_YYYYMMDD_dash: [
		'cardinality',
		'extended_stats',
		'percentiles',
		// 'percentile_ranks',
		'value_count'
	],
	date: [
		'cardinality',
		'percentiles',
		// 'percentile_ranks',
		'value_count'
	],
	string: [
		// 'string_stats'
	],
	float: [
		// 'weighted_avg',
		'cardinality',
		'extended_stats',
		'percentiles',
		// 'percentile_ranks',
		'value_count'
	],
	'string[]': [
		// 'value_count'
	],
	object: []
}

export function determineESType (field) {
	if (typeof field === 'string') {
		return field;
	}

	if (typeof field === 'object') {
		if ('es_type' in field) {
			return field.es_type;
		}
		if ('data_type' in field) {
			return field.data_type;
		}
		if ('type' in field) {
			return field.type;
		}

		// TODO: Should we throw or simply return 'object'?
		// throw new Error('Bad type specification');
	}

	return 'object';
}

/* eslint-disable no-unused-vars */
function defaultAggregationFactory (fieldName, fieldInfo) {
	// fieldInfo is specified here only to serve as an example
	// function signature for functions that return query parts.
	// These functions are all in `queryFactories` below.
	return { field: fieldName };
}

const queryFactories = {
	weighted_avg: (fieldName, fieldInfo) => {
		return {
			value: { field: fieldName },
			weight: { script: '1'}
		};
	},
	string_stats: (fieldName, fieldInfo) => {
		if (determineESType(fieldInfo) === 'ES_keyword') {
			return {
				value: { field: `${fieldName}.keyword` }
			};
		}

		return defaultAggregationFactory(fieldName, fieldInfo);
	}
}

export function buildAggregation(aggregation, fieldName, fieldInfo) {
	if (aggregation in queryFactories) {
		return queryFactories[aggregation](fieldName, fieldInfo);
	}

	return defaultAggregationFactory(fieldName, fieldInfo);
}

export function constructQuery(schema) {
	const fields = Object.keys(schema);
	const aggs = {};
	for (let f in schema) {
		const fType = determineESType(schema[f]);
		const typeAggs = aggregationsPerType[fType];
		for (let i in typeAggs) {
			const at = typeAggs[i];
			const atName = `${f}_${at}`;
			aggs[atName] = {
				[at]: buildAggregation(at, f, schema[f])
			};
		}
	}

	return {
		size: 0,
		aggs
	};
}
