export const descriptionsEN = {
    avg: "Average",
    weighted_avg: "Weighted Average",
    cardinality: "Cardinality",
    extended_stats: "Extended Statistics",
    geo_bounds: "Geographic Bounds",
    geo_centroid: "Geographic Centroid",
    max: "Maximum",
    min: "Minimum",
    percentiles: "Percentiles",
    percentile_ranks: "Percentile Ranks",
    scripted_metric: "Scripted Metric",
    stats: "Statistics",
    string_stats: "String Statistics",
    sum: "Sum",
    top_tags: "Top Hits",
    value_count: "Value Count",
    median_absolute_deviation: "Median Absolute Deviation"
}

export const aggregationsPerType = {
    ES_geo_point_obj: [
        'cardinality', 
        'geo_bounds', 
        'geo_centroid', 
        'value_count'
    ],
    ES_keyword: [
        'value_count',
        //'string_stats' //disabled until backend upgrade
    ],
    boolean: [
        'cardinality', 
        //'percentile_ranks', 
        'value_count'
    ],
    integer: [
        'cardinality', 
        'extended_stats', 
        //'percentile_ranks', 
        'value_count'
    ],
    Date_YYYYMMDD_dash: [
        'cardinality', 
        'extended_stats', 
        'percentiles', 
        //'percentile_ranks', 
        'value_count'
    ],
    date: [
        'cardinality', 
        'percentiles', 
        //'percentile_ranks', 
        'value_count'
    ],
    string: [
        //'string_stats' 
    ],
    float: [
        //'weighted_avg', 
        'cardinality', 
        'extended_stats', 
        'percentiles', 
        //'percentile_ranks', 
        'value_count'
    ],
    'string[]': [
        //'value_count'
    ],
    object: []
}

function defaultAggregationFactory (fieldName, fieldInfo) {
    // fieldInfo is specified here only to serve as an example
    // function signature for functions that return query parts.
    // These functions are all in `queryFactories` below.
    return { field: fieldName };
}

const queryFactories = {
    weighted_avg: (fieldName, fieldInfo) => { 
        return { 
            value: { field: fieldName },
            weight: { script: '1'}
        };
    },
    string_stats: (fieldName, fieldInfo) => {
        if (determineESType(fieldInfo) === 'ES_keyword') {
            return { 
                value: { field: `${fieldName}.keyword` }
            };    
        }
        return defaultAggregationFactory(fieldName);
    }
}

export function buildAggregation(aggregation, fieldName, fieldInfo) {
    if (aggregation in queryFactories)
        return queryFactories[aggregation](fieldName, fieldInfo);
    else 
        return defaultAggregationFactory(fieldName, fieldInfo);
}

export function determineESType(field) {
    if (typeof field === 'string')
        return field;
    if (typeof field === 'object') {
        if ('es_type' in field)
            return field.es_type;
        if ('data_type' in field)
            return field.data_type;
        if ('type' in field)
            return field.type;

        // TODO: Should we throw or simply return 'object'?
        // throw new Error('Bad type specification');
    }
    return 'object';
}

export function constructQuery(schema) {
    const fields = Object.keys(schema);
    const aggs = {};
    for ( let f in schema ) {
        const fType = determineESType(schema[f]);
        const typeAggs = aggregationsPerType[fType];
        for (let i in typeAggs) {
            const at = typeAggs[i];
            const atName = `${f}_${at}`;
            aggs[atName] = {
                [at]: buildAggregation(at, f, schema[f])
            };
        }
    }

    return {
        size: 0,
        aggs
    };
}
