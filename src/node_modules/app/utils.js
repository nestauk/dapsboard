import * as _ from 'lamb';
import { applyFnMap} from '@svizzle/utils';
// eslint-disable-next-line node/no-unpublished-import
import { tapValue } from '@svizzle/dev';
import { getESType } from 'app/elasticsearch';

export { version } from '../../../package.json';

const getSource = _.getKey('source');
const getVersion = _.getKey('version');

export const indexById = _.indexBy(_.getKey('id'));

export const makeDatasetBySource = _.pipe([
	_.groupBy(getSource),
	_.mapValuesWith(_.sortWith([_.getKey('project'), getVersion])),
	_.values,
	_.sortWith([getSource]),
	_.mapWith(applyFnMap({
		source: _.getPath('0.source'),
		releases: _.sortWith([getVersion])
	}))
]);

export const IS_BROWSER = process.browser;

export const getSchema = _.getPath('spec.dataset.schema');
export const getEndpointURL = _.getPath('spec.dataset.endpoint_url');

let lastId = 0;
export function autoID () {
	return `${IS_BROWSER ? 'client' : 'server'}${lastId++}`;
}

const createPropDefs = _.mapWith(([field, EStype]) => `	${field}: ${EStype};`);

const createTypeDef = ([datasetId, fieldEStypePairs]) => `export type ${datasetId} = {
	${createPropDefs(fieldEStypePairs).join('\n')}
};
`;

export const generateTypingsForAll = _.pipe([
	indexById,
	_.mapValuesWith(_.pipe([
		getSchema,
		_.mapValuesWith(getESType),
		_.pairs,
	])),
	_.pairs,
	_.mapWith(createTypeDef)
]);

/* URL parsing */

const traverseAggregation = applyFnMap({
	name: _.pipe([
		// tapValue('1'),
		_.getPath('0'),
	]),
	aggregation: _.pipe([
		_.getPath('1'),
		_.pairs,
		_.getPath('0.0'),
	]),
	field: _.pipe([
		_.getPath('1'),
		_.pairs,
		_.getPath('0.1'),
		_.getKey('field')
	]),
	params: _.pipe([
		_.getPath('1'),
		_.pairs,
		_.getPath('0.1'),
		_.skipKeys(['field'])
	]),
	subaggs: _.pipe([
		_.getPath('1'),
		_.pickKeys(['aggs']),
		_.pairs,
		_.getPath('0.1'),
		_.keys,
	]),
});

const traverseAggregations = _.pipe([
	tapValue('aggs'),
	_.pairs,
	_.collect([
		_.pipe([
			_.mapWith(traverseAggregation),
		]),
		_.pipe([
			_.getPath('0.1.aggs'),
			// traverseAggregations
			tapValue('subaggs')
		])
	]),
	_.shallowFlatten
]);

export const makeIntermediateObj = _.pipe([
	applyFnMap({
		resultSize: _.getPath('query.size'),
		dataset: _.getKey('dataset'),
		aggs: _.pipe([
			_.getPath('query.aggs'),
			traverseAggregations,
			// tapValue(0),

			// _.collect([
			//	_.pickKeys(['aggs']),
			// ]),
			// tapValue(3),

			// _.reduceWith((acc, ([key, obj])) => {
			// 	acc.aggs = obj.aggs;
			// 	acc.result = acc.result.concat(foo)
			// 	return acc;
			// }, {result: , aggs: })
		])
	}),
	tapValue('actual'),
]);

/*
_.reduceWith(
	(acc, [key, obj]) => {
		acc.aggs.push(obj.aggs);
		acc.result = acc.result.concat(foo)
		return acc;
	},
	{result: [], aggs: []}
);
*/

export const descentReducer = (hasChildren, getChildren) => {
	const reducer = _.curryable((reducerFn, init, node) => {
		const acc = reducerFn(init, node);
		if (!hasChildren(node)) {
			return acc;
		}
		return getChildren(node).reduce(reducer(reducerFn), acc);
	});
	return reducer;
}

/*
// Example usage of recursive reducer below

const rec = {
	primary: {
		aggs: {
			secondary: {
				aggs:{
					tertiary:{
						aggs: {
							child1: {
							}
						}
					},
					sibling: {
						aggs: {
							child2: {
							}
						}
					}
				}
			}
		}
	}
};

const transformAgg =
			applyFnMap({
				name: _.pipe([
					_.getPath('0'),
					// tapValue('name')
				]),
				subaggs: _.pipe([
					_.getPath('1'),
					_.casus(
						_.hasKey('aggs'),
						_.pipe([
							_.getKey('aggs'),
							_.pairs,
							_.mapWith( v => v[0]),
						])
					),
					// tapValue('subaggs'),
				])
			});

//const hasSubAggs = pair => Boolean(pair[0][1].aggs)
const hasSubAggs = _.pipe([
	_.getPath('1'),
	_.hasKey('aggs'),
	// tapValue('has'),
]);
//const getSubAggs = pair => _.pairs(pair[0][1].aggs);
const getSubAggs = _.pipe([
	_.getPath('1'),
	// tapValue('beforeget'),
	_.getKey('aggs'),
	// tapValue('beforeget2'),
	_.pairs,
	// tapValue('get'),
])
//const appendAggs = (total, pair) => [...total, pair];
const appendAggs = (total, pair) => [
	...total,
	_.pipe([
		transformAgg,
		// tapValue('append')
	])(pair)];

const transformSingle =
	_.pipe([
		_.pairs,
		_.getPath('0'),
		// tapValue('start single'),
		transformAgg,
]);

const transformAll =
	_.pipe([
		_.pairs,
		_.getPath('0'),
		// tapValue('start all'),
		descentReducer(hasSubAggs, getSubAggs)(appendAggs)([]),
]);

const result = transformAll(rec);
*/
