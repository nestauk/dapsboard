// eslint-disable-next-line node/no-unpublished-import
import { writable } from 'svelte/store';
// eslint-disable-next-line node/no-unpublished-import
import { Machine, interpret } from 'xstate';
import * as _ from 'lamb';
import { applyFnMap } from '@svizzle/utils';
import { getESType } from 'app/elasticsearch';

export { version } from '../../../package.json';

const getSource = _.getKey('source');
const getVersion = _.getKey('version');

export const indexById = _.indexBy(_.getKey('id'));

export const makeDatasetBySource = _.pipe([
	_.groupBy(getSource),
	_.mapValuesWith(_.sortWith([_.getKey('project'), getVersion])),
	_.values,
	_.sortWith([getSource]),
	_.mapWith(applyFnMap({
		source: _.getPath('0.source'),
		releases: _.sortWith([getVersion])
	}))
]);

export const IS_BROWSER = process.browser;

export const getSchema = _.getPath('spec.dataset.schema');
export const getEndpointURL = _.getPath('spec.dataset.endpoint_url');

let lastId = 0;
export function autoID () {
	return `${IS_BROWSER ? 'client' : 'server'}${lastId++}`;
}

const createPropDefs = _.mapWith(([field, EStype]) => `	${field}: ${EStype};`);

const createTypeDef = ([datasetId, fieldEStypePairs]) => `export type ${datasetId} = {
	${createPropDefs(fieldEStypePairs).join('\n')}
};
`;

export const generateTypingsForAll = _.pipe([
	indexById,
	_.mapValuesWith(_.pipe([
		getSchema,
		_.mapValuesWith(getESType),
		_.pairs,
	])),
	_.pairs,
	_.mapWith(createTypeDef)
])

/**
 * Creates an xstate machine and places it into a svelte store.
 * Also creates a svelte store to be passed to the machine as context
 *
 * @param machineConfig - A valid xstate configuration object
 * @param machineOptions - A valid xstate options object: guards, actions, services, activities
 * @param contextStores - The default store(s) to be passed to xstate as context
 * @returns An object containing two objects. One being a store containing the xstate machine, the other containing the stores passed in as context.
 *
 */

export function createMachina (machineConfig, machineOptions, contextStores) {
	const machine = Machine(machineConfig, machineOptions);
	const service = interpret(machine.withContext(contextStores));

	const machineStore = writable(machine.initialState, () => {
		service.start();
		return () => service.stop();
	});

	service.onTransition(nextState => {
		machineStore.set(nextState);
	});

	service.start();

	return {
		machine: {
			subscribe: machineStore.subscribe,
			send: service.send,
		},
		contextStores,
	};
}
