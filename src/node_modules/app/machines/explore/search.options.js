import * as _ from 'lamb';
import {get} from 'svelte/store';

import {assign, send} from 'xstate';
import {applyFnMap, makeIsIncluded} from '@svizzle/utils';
import {getSearchURL} from 'utils/specs';
import {request} from 'utils/net';
import {
	selectedDataset,
	selectedDatasetSchema
} from 'app/stores/exploreStores';
// const cache = {};

const keywordFieldTypes = [
	'keyword',
	'keywordArray',
	'textWithKeyword',
	'textWithKeywordArray'
];

const getKeywordFields = _.pipe([
	_.pairs,
	_.filterWith(_.pipe([
		_.getPath('1.type'),
		makeIsIncluded(keywordFieldTypes)
	])),
	_.mapWith(_.getAt(0))
]);

const extractCountInfo = applyFnMap({
	name: _.getAt(0),
	count: _.getPath('1.doc_count')
});

const mapResponseToFieldCount = _.pipe([
	_.getPath('aggregations.messages.buckets'),
	_.pairs,
	_.mapWith(extractCountInfo),
	_.sortWith([_.getKey('count')]),
	_.reverse
])


/*
function computeSuggestionsQuery (requestedFieldName, term) {
	return {
		size: 0,
		query: {
			term: {
				[requestedFieldName]: term
			}
		},
		aggs: {
			[requestedFieldName]: {
				significant_text: {
					field: requestedFieldName,
					include: stopWords,
					min_doc_count: 1
				}
			}
		}
	};
}
*/

/*
async function sendSearchRequest (event) {
	response = null;
	awaitingResponse = true;
	const data = computeSearchQuery(event.detail);
	response = await sendRequest(data);
	awaitingResponse = false;
}
*/

// common options
// Fields options
// function setCacheKey = ({setCacheKey}, {detail}) =>
//	cache[]
/*
function updateStatsCache ({statsCacheKey}, {data}) {
	cache[statsCacheKey] = data;
}
const isInStatsCache = ({statsCacheKey}) => get(statsCachy) in cache;
*/

function computeSelection (fieldCounts, userSelection) {
	const exists = fieldCounts.some(item => item.name === userSelection);
	if (!userSelection || !exists) {
		if (fieldCounts.length > 0) {
			return fieldCounts[0].name;
		}
		return null;
	}
	return userSelection;
}
function computeCountQuery (keywordFields, searchTerm) {
	const query = {
		size: 0,
		aggs : {
			messages : {
				filters : {
					filters : _.fromPairs(keywordFields.map(name => [name, {
						term : {
							[name] : searchTerm
						}
					}]))
				}
			}
		}
	};
	return query;
}

function fieldsStatsRequest ({searchQuery}) {
	const data = computeCountQuery(
		getKeywordFields(get(selectedDatasetSchema)),
		get(searchQuery)
	);
	const url = getSearchURL(get(selectedDataset));
	return request('POST', url, {data});
}

function updateFields ({
	fieldCounts,
	userSelection,
	selectedFieldName,
	isFieldsMenuActive
}, {data}) {
	fieldCounts.set(
		mapResponseToFieldCount(data)
		.filter(field =>
			field.count > 0 || field.name === get(userSelection)
		)
	);
	selectedFieldName.set(computeSelection(
		get(fieldCounts),
		get(userSelection)
	));
	isFieldsMenuActive.set(true);
	return {
		fieldCounts,
		selectedFieldName,
		isFieldsMenuActive
	};
}

function updateSearchQuery ({searchQuery}, {detail}) {
	searchQuery.set(detail.trim().toLowerCase());
	return {searchQuery};
}

function updateQuery ({isFieldsMenuActive}) {
	isFieldsMenuActive.set(false);
	return {isFieldsMenuActive};
}

/*
async function sendSuggestionsRequest (ctx, event) {
	const fieldName = event.detail;
	// 1. request
	const info = get(ctx.fieldCounts).find(fieldInfo => fieldInfo.name === fieldName)
	if (info.suggestions) {
		return;
	}
	info.suggestions = ['waiting...'];
	fieldCounts = fieldCounts;
	const payload = computeSuggestionsQuery(fieldName, searchValue);
	const suggestionsResponse = await sendRequest(payload);
	// TODO check for error messages
	let {buckets} = suggestionsResponse.aggregations[fieldName];
	buckets = buckets.filter(sugg => sugg.key !== searchValue);
	buckets = buckets.sort((a, b) => b.doc_count - a.doc_count);
	info.suggestions = buckets.map(sugg => `${sugg.key} (${sugg.doc_count})`);
	if (info.suggestions.length === 0) {
		info.suggestions.push('-- no suggestions found --')
	}
	fieldCounts = fieldCounts;
	console.log("countRespoonse", info);
}
*/

/*
function onFieldSelected (event) {
	userSelection = event.detail;
	selectedFieldName = computeSelection(fieldCounts);
}
function selectNext () {
	let index = fieldCounts.findIndex(field =>
		field.name === selectedFieldName
	);
	index++;
	if (index < fieldCounts.length) {
		userSelection = fieldCounts[index].name;
		selectedFieldName = computeSelection(fieldCounts);
	}
}
function selectPrevious () {
	let index = fieldCounts.findIndex(field =>
		field.name === selectedFieldName
	);
	index--;
	if (index >= 0) {
		userSelection = fieldCounts[index].name;
		selectedFieldName = computeSelection(fieldCounts);
	}
}
*/

export const searchOptions = {
	actions: {
		sendSearchQueryUpdated: send('SEARCH_QUERY_UPDATED'),
		updateQuery,
		updateSearchQuery: assign(updateSearchQuery),
		// sendQueryUpdated: send('QUERY_UPDATED'),
		// updateStatsCache,
		updateFields,
	},
	guards: {
		// isInStatsCache,
	},
	services: {
		fieldsStatsRequest,
	}
};
