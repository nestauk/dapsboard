import * as _ from 'lamb';
import {get} from 'svelte/store';

import {assign, send} from 'xstate';
import {applyFnMap, makeIsIncluded} from '@svizzle/utils';
import {getSearchURL} from 'utils/specs';
import {request} from 'utils/net';
import {
	selectedDataset,
	selectedDatasetSchema
} from 'app/stores/exploreStores';
import {stopWords} from 'utils/stopwords';

// Fields utils
const makeGetFieldsOfTypes = types => _.pipe([
	_.pairs,
	_.filterWith(_.pipe([
		_.getPath('1.type'),
		makeIsIncluded(types)
	])),
	_.mapWith(_.getAt(0))
]);

const getKeywordFields = makeGetFieldsOfTypes([
	'keyword',
	'keywordArray',
	'textWithKeyword',
	'textWithKeywordArray'
]);

// TODO make functional
function computeFieldSelection (fieldStats, userSelection) {
	const exists = fieldStats.some(item => item.name === userSelection);
	if (!userSelection || !exists) {
		if (fieldStats.length > 0) {
			return fieldStats[0].name;
		}
		return null;
	}
	return userSelection;
}

const computeCountQuery = (keywordFields, searchTerm) => ({
	size: 0,
	aggs : {
		messages : {
			filters : {
				filters : _.fromPairs(keywordFields.map(name => [name, {
					term : {
						[name] : searchTerm
					}
				}]))
			}
		}
	}
});

// Fields options
const extractCountInfo = applyFnMap({
	name: _.getAt(0),
	count: _.getPath('1.doc_count')
});

const mapResponseToFieldCount = _.pipe([
	_.getPath('aggregations.messages.buckets'),
	_.pairs,
	_.mapWith(extractCountInfo),
	_.sortWith([_.getKey('count')]),
	_.reverse
]);

const fieldsStatsRequest = ({searchQuery}) => {
	const data = computeCountQuery(
		getKeywordFields(get(selectedDatasetSchema)),
		get(searchQuery)
	);
	const url = getSearchURL(get(selectedDataset));
	return request('POST', url, {data});
};

const updateFieldStats = ({
	fieldStats,
	userSelection,
	selectedFieldName
}, {data}) => {
	const $fieldStats = mapResponseToFieldCount(data).filter(field =>
		field.count > 0
	);
	fieldStats.set($fieldStats);
	if ($fieldStats.length === 0) {
		userSelection.set(null);
	}
	selectedFieldName.set(computeFieldSelection(
		get(fieldStats),
		get(userSelection)
	));
	return {
		fieldStats,
		selectedFieldName,
		userSelection
	};
};

const setStatsCacheKey = ({
	dataset,
	searchQuery,
	statsCacheKey,
}) => {
	const {project, source, version} = get(dataset);
	const $searchQuery = get(searchQuery);
	statsCacheKey.set(`${project}-${source}-${version}-${$searchQuery}`);
	return {statsCacheKey};
};

const updateStatsCache = ({statsCache, statsCacheKey}, {data}) => {
	statsCache.update(_.setKey(get(statsCacheKey), data));
	return {statsCache};
};

const loadFieldStatsFromCache = ({
	statsCache,
	statsCacheKey,
	fieldStats,
	userSelection,
	selectedFieldName
}) => updateFieldStats(
	{
		fieldStats,
		userSelection,
		selectedFieldName
	},
	{data: get(statsCache)[get(statsCacheKey)]}
);

const isInStatsCache = ({statsCache, statsCacheKey}) =>
	get(statsCacheKey) in get(statsCache);

const setMenuActive = ({isFieldsMenuActive}) => {
	isFieldsMenuActive.set(true);
	return {isFieldsMenuActive};
}

const setMenuInactive = ({isFieldsMenuActive}) => {
	isFieldsMenuActive.set(false);
	return {isFieldsMenuActive};
}

const updateSearchQuery = ({searchQuery}, {detail}) => {
	searchQuery.set(detail.trim().toLowerCase());
	return {searchQuery};
}

function selectNextSearchField ({
	fieldStats,
	selectedFieldName,
	userSelection
}) {
	const $fieldStats = get(fieldStats);
	let index = $fieldStats.findIndex(field =>
		field.name === get(selectedFieldName)
	);
	index++;
	if (index < $fieldStats.length) {
		userSelection.set($fieldStats[index].name);
		selectedFieldName.set(computeFieldSelection(
			$fieldStats,
			get(userSelection))
		);
	}
	return {selectedFieldName, userSelection};
}

function selectPrevSearchField ({
	fieldStats,
	selectedFieldName,
	userSelection
}) {
	const $fieldStats = get(fieldStats);
	let index = $fieldStats.findIndex(field =>
		field.name === get(selectedFieldName)
	);
	index--;
	if (index >= 0) {
		userSelection.set($fieldStats[index].name);
		selectedFieldName.set(computeFieldSelection(
			$fieldStats,
			get(userSelection))
		);
	}
	return {selectedFieldName, userSelection};
}

function updateCurrentField ({
	fieldStats,
	selectedFieldName,
	userSelection
}, {detail}) {
	userSelection.set(detail);
	selectedFieldName.set(computeFieldSelection(
		get(fieldStats),
		get(userSelection)
	));
	return {selectedFieldName, userSelection};
}

// Suggestions utils
const computeSuggestionsQuery = (requestedFieldName, term) => ({
	size: 0,
	query: {
		term: {
			[requestedFieldName]: term
		}
	},
	aggs: {
		[requestedFieldName]: {
			significant_text: {
				field: requestedFieldName,
				// TODO include/exclude according to ES version
				include: stopWords,
				min_doc_count: 1
			}
		}
	}
});

// Suggestions options
const isSuggestionsRequestIncomplete = ({searchQuery, selectedFieldName}) =>
	!(Boolean(get(searchQuery)) && Boolean(get(selectedFieldName)));

const suggestionsRequest = ({searchQuery, selectedFieldName}) => request(
	'POST',
	getSearchURL(get(selectedDataset)),
	{data: computeSuggestionsQuery(get(selectedFieldName), get(searchQuery))}
);

const updateSuggestionsCache = ({
	suggestionsCache,
	suggestionsCacheKey,
}, {data}) => {
	suggestionsCache.update(_.setKey(get(suggestionsCacheKey), data));
	return {suggestionsCache};
};

const updateSuggestions = ({
	searchQuery,
	selectedFieldName,
	suggestions,
}, {data}) => {
	const aggs = data.aggregations[get(selectedFieldName)];
	const buckets = (aggs && aggs.buckets || [])
	.filter(sugg => sugg.key !== get(searchQuery));
	const sortedBuckets = _.sort(buckets, [
		_.sorterDesc(_.getKey('doc_count')),
		_.getKey('key')]
	);
	const $suggestions = sortedBuckets
	.map(sugg => `${sugg.key} (${sugg.doc_count})`);
	if ($suggestions.length === 0) {
		$suggestions.push('-- no suggestions found --')
	}
	suggestions.set($suggestions);
	return {suggestions};
}

const setAsWaiting = ({
	suggestions
}) => {
	const $suggestions = ["Waiting..."];
	suggestions.set($suggestions);
	return {suggestions};
}

const setSuggestionsCacheKey = ({
	dataset,
	searchQuery,
	selectedFieldName,
	suggestionsCacheKey,
}) => {
	const {project, source, version} = get(dataset);
	const $searchQuery = get(searchQuery);
	const $selectedFieldName = get(selectedFieldName);
	suggestionsCacheKey.set(`${project}-${source}-${version}-${$searchQuery}-${$selectedFieldName}`);
	return {suggestionsCacheKey};
};

const isInSuggestionsCache = ({suggestionsCache, suggestionsCacheKey}) =>
	get(suggestionsCacheKey) in get(suggestionsCache);

const loadSuggestionsFromCache = ({
	suggestionsCache,
	suggestionsCacheKey,
	searchQuery,
	selectedFieldName,
	suggestions
}) => updateSuggestions(
	{
		searchQuery,
		selectedFieldName,
		suggestions
	},
	{data: get(suggestionsCache)[get(suggestionsCacheKey)]}
);

export const searchOptions = {
	actions: {
		loadStatsFromCache: assign(loadFieldStatsFromCache),
		loadSuggestionsFromCache: assign(loadSuggestionsFromCache),
		selectNextSearchField: assign(selectNextSearchField),
		selectPrevSearchField: assign(selectPrevSearchField),
		sendFieldUpdated: send('FIELD_UPDATED'),
		// sendQueryUpdated: send('QUERY_UPDATED'), // Leaving tie-in for last
		sendSearchQueryUpdated: send('SEARCH_QUERY_UPDATED'),
		setAsWaiting: assign(setAsWaiting),
		setMenuActive: assign(setMenuActive),
		setMenuInactive: assign(setMenuInactive),
		setStatsCacheKey: assign(setStatsCacheKey),
		setSuggestionsCacheKey: assign(setSuggestionsCacheKey),
		updateCurrentField: assign(updateCurrentField),
		updateFieldStats: assign(updateFieldStats),
		// updateQuery: assign(updateQuery),
		updateSearchQuery: assign(updateSearchQuery),
		updateStatsCache: assign(updateStatsCache),
		updateSuggestions: assign(updateSuggestions),
		updateSuggestionsCache: assign(updateSuggestionsCache)
	},
	guards: {
		isInStatsCache,
		isInSuggestionsCache,
		isSuggestionsRequestIncomplete
	},
	services: {
		fieldsStatsRequest,
		suggestionsRequest
	}
};
