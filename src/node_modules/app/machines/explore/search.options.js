import * as _ from 'lamb';
import {get} from 'svelte/store';

import {assign, send} from 'xstate';
import {applyFnMap, makeIsIncluded} from '@svizzle/utils';
import {getSearchURL} from 'utils/specs';
import {request} from 'utils/net';
import {
	selectedDataset,
	selectedDatasetSchema
} from 'app/stores/exploreStores';
import {stopWords} from 'utils/stopwords';
import {createBaseSearchStores} from './search.context';

// Fields utils
const makeGetFieldsOfTypes = types => _.pipe([
	_.pairs,
	_.filterWith(_.pipe([
		_.getPath('1.type'),
		makeIsIncluded(types)
	])),
	_.mapWith(_.getAt(0))
]);

const getKeywordFields = makeGetFieldsOfTypes([
	'keyword',
	'keywordArray',
	'textWithKeyword',
	'textWithKeywordArray'
]);

function computeFieldSelection (fieldStats, userSelection) {
	const exists = fieldStats.some(item => item.name === userSelection);
	if (userSelection && exists) {
		return userSelection;
	}
	if (fieldStats.length > 0) {
		return fieldStats[0].name;
	}
	return null;
}

const computeCountQuery = (keywordFields, searchTerm) => ({
	size: 0,
	aggs : {
		messages : {
			filters : {
				filters : _.fromPairs(keywordFields.map(name => [name, {
					term : {
						[name] : searchTerm
					}
				}]))
			}
		}
	}
});


// Fields options
const getCountInfo = applyFnMap({
	name: _.getAt(0),
	count: _.getPath('1.doc_count')
});

const mapResponseToFieldCount = _.pipe([
	_.getPath('aggregations.messages.buckets'),
	_.pairs,
	_.mapWith(getCountInfo),
	_.sortWith([_.sorterDesc(_.getKey('count'))]),
]);

const fieldsStatsRequest = ({searchQuery}) => {
	const data = computeCountQuery(
		getKeywordFields(get(selectedDatasetSchema)),
		get(searchQuery)
	);
	const url = getSearchURL(get(selectedDataset));
	return request('POST', url, {data});
};

const updateFieldStats = (ctx, {data}) => {
	const fieldStats = mapResponseToFieldCount(data).filter(field =>
		field.count > 0
	);
	ctx.fieldStats.set(fieldStats);
	if (fieldStats.length === 0) {
		ctx.userSelection.set(null);
	}
	const fieldNames = fieldStats.map(field => field.name);
	const nextFieldNames = fieldNames.slice(1);
	const prevFieldNames = fieldNames.slice(0,-1);
	ctx.nextFieldNames.set(_.fromPairs(_.zip(prevFieldNames, nextFieldNames)));
	ctx.prevFieldNames.set(_.fromPairs(_.zip(nextFieldNames, prevFieldNames)));
	ctx.selectedFieldName.set(computeFieldSelection(
		get(ctx.fieldStats),
		get(ctx.userSelection)
	));
	return ctx;
};

const setStatsCacheKey = ctx => {
	const {project, source, version} = get(ctx.dataset);
	const searchQuery = get(ctx.searchQuery);
	ctx.statsCacheKey.set(`${project}-${source}-${version}-${searchQuery}`);
	return ctx;
};

const updateStatsCache = (ctx, {data}) => {
	ctx.statsCache.update(_.setKey(get(ctx.statsCacheKey), data));
	return ctx;
};

const loadFieldStatsFromCache = ctx => updateFieldStats(
	ctx,
	{data: get(ctx.statsCache)[get(ctx.statsCacheKey)]}
);

const isInStatsCache = ctx =>
	get(ctx.statsCacheKey) in get(ctx.statsCache);

const setMenuActive = ctx => {
	ctx.isFieldsMenuActive.set(true);
	return ctx;
}

const setMenuInactive = ctx => {
	ctx.isFieldsMenuActive.set(false);
	return ctx;
}

const updateSearchQuery = (ctx, {detail}) => {
	ctx.searchQuery.set(detail.trim().toLowerCase());
	return ctx;
}

function selectNextSearchField (ctx) {
	const selectedFieldName = get(ctx.selectedFieldName);
	const nextFieldNames = get(ctx.nextFieldNames);
	const nextFieldId = nextFieldNames[selectedFieldName];
	if (nextFieldId) {
		ctx.userSelection.set(nextFieldId);
		ctx.selectedFieldName.set(computeFieldSelection(
			get(ctx.fieldStats),
			get(ctx.userSelection)
		));
	}
	return ctx;
}

function selectPrevSearchField (ctx) {
	const selectedFieldName = get(ctx.selectedFieldName);
	const prevFieldNames = get(ctx.prevFieldNames);
	const prevFieldId = prevFieldNames[selectedFieldName];
	if (prevFieldId) {
		ctx.userSelection.set(prevFieldId);
		ctx.selectedFieldName.set(computeFieldSelection(
			get(ctx.fieldStats),
			get(ctx.userSelection)
		));
	}
	return ctx;
}

function updateCurrentField (ctx, {detail}) {
	ctx.userSelection.set(detail);
	ctx.selectedFieldName.set(computeFieldSelection(
		get(ctx.fieldStats),
		get(ctx.userSelection)
	));
	return ctx;
}

// Suggestions utils
const computeSuggestionsQuery = (requestedFieldName, term) => ({
	size: 0,
	query: {
		term: {
			[requestedFieldName]: term
		}
	},
	aggs: {
		[requestedFieldName]: {
			significant_text: {
				field: requestedFieldName,
				// TODO include/exclude according to ES version
				include: stopWords,
				min_doc_count: 1,
				size: 20
			}
		}
	}
});

// Suggestions options
const isSuggestionsRequestIncomplete = ctx =>
	!(Boolean(get(ctx.searchQuery)) && Boolean(get(ctx.selectedFieldName)));

const suggestionsRequest = ctx => request(
	'POST',
	getSearchURL(get(selectedDataset)),
	{
		data: computeSuggestionsQuery(
			get(ctx.selectedFieldName),
			get(ctx.searchQuery)
		)
	}
);

const updateSuggestionsCache = (ctx, {data}) => {
	ctx.suggestionsCache.update(_.setKey(get(ctx.suggestionsCacheKey), data));
	return ctx;
};

const updateSuggestions = (ctx, {data}) => {
	const aggs = data.aggregations[get(ctx.selectedFieldName)];
	const buckets =
		(aggs && aggs.buckets || [])
		.filter(sugg => sugg.key !== get(ctx.searchQuery));
	const sortedBuckets = _.sort(buckets, [
		_.sorterDesc(_.getKey('doc_count')),
		_.getKey('key')]
	);
	const suggestions =
		sortedBuckets
		.map(sugg => `${sugg.key} (${sugg.doc_count})`);
	if (suggestions.length === 0) {
		suggestions.push('-- no suggestions found --')
	}
	ctx.suggestions.set(suggestions);
	return ctx;
}

const setAsWaiting = ctx => {
	const suggestions = ["Waiting..."];
	ctx.suggestions.set(suggestions);
	return ctx;
}

const setSuggestionsCacheKey = ctx => {
	const {project, source, version} = get(ctx.dataset);
	const searchQuery = get(ctx.searchQuery);
	const selectedFieldName = get(ctx.selectedFieldName);
	ctx.suggestionsCacheKey.set(
		`${project}-${source}-${version}-${searchQuery}-${selectedFieldName}`
	);
	return ctx;
};

const isInSuggestionsCache = ctx =>
	get(ctx.suggestionsCacheKey) in get(ctx.suggestionsCache);

const loadSuggestionsFromCache = ctx => updateSuggestions(
	ctx,
	{data: get(ctx.suggestionsCache)[get(ctx.suggestionsCacheKey)]}
);

export const searchOptions = {
	actions: {
		loadStatsFromCache: assign(loadFieldStatsFromCache),
		loadSuggestionsFromCache: assign(loadSuggestionsFromCache),
		resetSearchContext: assign(createBaseSearchStores),
		selectNextSearchField: assign(selectNextSearchField),
		selectPrevSearchField: assign(selectPrevSearchField),
		sendFieldUpdated: send('FIELD_UPDATED'),
		// sendQueryUpdated: send('QUERY_UPDATED'), // Leaving tie-in for last
		sendSearchQueryUpdated: send('SEARCH_QUERY_UPDATED'),
		setAsWaiting: assign(setAsWaiting),
		setMenuActive: assign(setMenuActive),
		setMenuInactive: assign(setMenuInactive),
		setStatsCacheKey: assign(setStatsCacheKey),
		setSuggestionsCacheKey: assign(setSuggestionsCacheKey),
		updateCurrentField: assign(updateCurrentField),
		updateFieldStats: assign(updateFieldStats),
		// updateQuery: assign(updateQuery),
		updateSearchQuery: assign(updateSearchQuery),
		updateStatsCache: assign(updateStatsCache),
		updateSuggestions: assign(updateSuggestions),
		updateSuggestionsCache: assign(updateSuggestionsCache)
	},
	guards: {
		isInStatsCache,
		isInSuggestionsCache,
		isSuggestionsRequestIncomplete
	},
	services: {
		fieldsStatsRequest,
		suggestionsRequest
	}
};
