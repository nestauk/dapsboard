// eslint-disable-next-line node/no-unpublished-import
import { writable } from 'svelte/store';
import * as _ from 'lamb';
// eslint-disable-next-line node/no-extraneous-import
import {capitalise} from 'svizzle/utils/string-string';
/*
import {
	metricLabels,
	bucketLabels,
	aggsByType
} from '../../elasticsearch/config';
import { getESType } from '../../elasticsearch';

/*
const aggregations = {};
const datasets = {};
const fields = {};
const types = {};

const fieldNamesSet = new Set();
const typeNamesSet = new Set();

for (let index in DATASETS) {
	const dataset = DATASETS[index];
	const newDataset = {
		aggregations: new Set(),
		types: new Set(),
		fields: new Set(),
		index
	};
	datasets[dataset.id] = newDataset;

	const schema = getSchema(dataset);
	for (let field in schema) {
		fieldNamesSet.add(field);
		newDataset.fields.add(field);

		const esType = getESType(schema[field]);
		typeNamesSet.add(esType)
		newDataset.types.add(esType);

		const aggs = aggsByType[esType]
		if (aggs) {
			aggs.forEach(agg => {
				newDataset.aggregations.add(agg);
			})
		}
	}
}

const typeNames = Array.from(typeNamesSet).sort();
for (let esType of typeNames) {
	types[esType] = {
		aggregations: new Set(aggsByType[esType]),
		datasets: new Set(
			Object.keys(datasets)
			.filter(dsName => datasets[dsName].types.has(esType))
		),
		fields: new Set()
	}
}

const fieldNames = Array.from(fieldNamesSet).sort();
for (let field of fieldNames) {
	const _datasets = new Set(
		Object.keys(datasets)
		.filter(dsName => datasets[dsName].fields.has(field))
	)
	const _types = new Set(
		Object.keys(datasets)
		.filter(dsName => datasets[dsName].fields.has(field))
		.map(dsName => getESType(getSchema(DATASETS[datasets[dsName].index])[field]))
	);
	const _aggregations = new Set();
	for (let esType of _types) {
		const aggs = aggsByType[esType];
		if (aggs) {
			aggs.forEach(agg => _aggregations.add(agg));
		}
		types[esType].fields.add(field);
	}
	fields[field] = {
		datasets: _datasets,
		types: _types,
		aggregations: _aggregations
	};
}

for (let agg of Object.keys(metricLabels)) {
	aggregations[agg] = {
		types: new Set(
			Object.keys(types)
			.filter(esType => types[esType].aggregations.has(agg))
		),
		datasets: new Set(
			Object.keys(datasets)
			.filter(dsName => datasets[dsName].aggregations.has(agg))
		),
		fields: new Set(
			Object.keys(fields)
			.filter(field => fields[field].aggregations.has(agg))
		)
	}
}

for (let agg of Object.keys(bucketLabels)) {
	aggregations[agg] = {
		types: new Set(
			Object.keys(types)
			.filter(esType => types[esType].aggregations.has(agg))
		),
		datasets: new Set(
			Object.keys(datasets)
			.filter(dsName => datasets[dsName].aggregations.has(agg))
		),
		fields: new Set(
			Object.keys(fields)
			.filter(field => fields[field].aggregations.has(agg))
		)
	}
}
*/

const AXIS_NAMES = [
	'primary',
	'secondary',
	'tertiary',
	'quaternary',
	'quinary',
	'senary',
	'septenary',
	'octonary',
	'nonary',
	'denary'
];
/*
let axisParams = _.fromPairs(AXIS_NAMES.map(name =>
	[name, {
		input: {},
		pureOutput: null,
		output: null
	}]
));
*/
let axisOptions = AXIS_NAMES.map(name => ({
	text: capitalise(name),
	value: name,
	disabled: true
}));

let [sa] = AXIS_NAMES;
let qc = {
	dataset: undefined,
	axes: _.fromPairs(AXIS_NAMES.map(name =>
		[name, {
			aggregation: null,
			type: null,
			field: null,
		}]
	))
};

export function createBuilderStores () {
	return {
		// 'consts'
		AXIS_NAMES,
		// config
		axisOptions,
		runQueryOnSelect: writable(false),
		hideDisabledForms: writable(true),
		hideDisabledAggregations: writable(false),
		hideDisabledDatasets: writable(false),
		hideDisabledFields: writable(true),
		selectedAxis: writable(sa),
		selectedRequestTab: writable(null),
		showFullResponse: writable(false),
		// doc strings
		activeDocs: writable(''),
		aggDocText: writable('...'),
		// builder
		bucketOptions: writable([]),
		aggregatorOptions: writable([]),
		typeOptions: writable([]),
		datasetOptions: writable([]),
		fieldOptions: writable([]),
		resultSize: writable(0),
		readyForRequest: writable(false),
		responsePromise: writable(null),
		selectedFieldCompletions: writable([]),
		selectedParams: writable(),
		queryTemplate: writable({}),
		parsedQuery: writable({}),
		queryConfig: writable(qc),
		selectedAxisConfig: writable(qc.axes[sa]),
		// internal stuff
		datasetTypings: null,
	}
}
