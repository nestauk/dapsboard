// eslint-disable-next-line node/no-unpublished-import
import * as _ from 'lamb';
// eslint-disable-next-line node/no-unpublished-import
import { isObjNotEmpty } from '@svizzle/utils';
// eslint-disable-next-line node/no-unpublished-import
import { get } from 'svelte/store';
// eslint-disable-next-line node/no-unpublished-import
import rison from 'rison-esm';

function formData (machine) {
	const data = {
		name: machine.context.id,
	}
	const selection = get(machine.context.selection);
	if (selection && isObjNotEmpty(selection)) {
		const result = {};
		Object.keys(selection).forEach(s =>
			!_.isNil(selection[s]) && (result[s] = selection[s])
		);
		isObjNotEmpty(result) && (data.selection = result);
	}
	const params = get(machine.context.params);
	params && isObjNotEmpty(params) && (data.params = params);
	return data;
}

function collectConfiguration (ctx) {
	const config = {
		size: get(ctx.resultSize),
		form: get(get(ctx.selectedForm).machine).context.id,
		forms: get(ctx.forms).map(form => formData(get(form.machine))),
	}

	const dataset = get(ctx.dataset);
	dataset && (config.dataset = dataset);
	return config;
}

function updateEntry (ctx, event) {
	const query = rison.encode(collectConfiguration(ctx));
	const url = `${window.location.pathname}?q=${query}`;
	const updateType = event.init
		? 'pushState'
		: 'replaceState';
	console.log(event, updateType, get(ctx.isUserInteraction))
	history[updateType](null, window.title, url);
}

export const historyOptions = {
	actions: {
		/**
		 * When editing starts reserves a history slot for the session
		 */
		initEntry: ctx => updateEntry(ctx, {init: true}),
		/**
		 * Updates the history slot on edits
		 */
		updateEntry,
		commitEntry: () => console.log('Entering Saved state')
	},
	guards: {
	}
};
