// eslint-disable-next-line node/no-unpublished-import
import { get } from 'svelte/store';
// eslint-disable-next-line node/no-unpublished-import
import rison from 'rison-esm';

function isEmpty (obj) {
	for (let prop in obj) {
		if (obj.hasOwnProperty(prop)) {
			return false;
		}
	}

	return JSON.stringify(obj) === JSON.stringify({});
}

const hasValue = obj => obj !== null && obj !== undefined;

function formData (machine) {
	const data = {
		name: machine.context.id,
	}
	const selection = get(machine.context.selection);
	if (selection && !isEmpty(selection)) {
		const result = {};
		Object.keys(selection).forEach(s =>
			hasValue(selection[s]) && (result[s] = selection[s])
		);
		!isEmpty(result) && (data.selection = result);
	}
	const params = get(machine.context.params);
	params && !isEmpty(params) && (data.params = params);
	return data;
}

function collectConfiguration (ctx) {
	const config = {
		size: get(ctx.resultSize),
		form: get(get(ctx.selectedForm).machine).context.id,
		forms: get(ctx.forms).map(form => formData(get(form.machine))),
	}

	const dataset = get(ctx.dataset);
	dataset && (config.dataset = dataset);
	return config;
}

function updateEntry (ctx, event) {
	const query = rison.encode(collectConfiguration(ctx));
	const url = `${window.location.pathname}?q=${query}`;
	const updateType = event.init ? 'pushState' : 'replaceState';
	history[updateType](null, window.title, url);
}

export const historyOptions = {
	actions: {
		/**
		 * When editing starts reserves a history slot for the session
		 */
		initEntry: ctx => updateEntry(ctx, {init: true}),
		/**
		 * Updates the history slot on edits
		 */
		updateEntry,
		/**
		 * When edditing is completed, close the editing session
		 */
		commitEntry: () => console.log('committed'),
	},
	guards: {
	}
};
