// eslint-disable-next-line node/no-unpublished-import
import * as _ from 'lamb';
// eslint-disable-next-line node/no-unpublished-import
import { get } from 'svelte/store';
// eslint-disable-next-line node/no-unpublished-import
import { spawn } from 'xstate';
// eslint-disable-next-line node/no-unpublished-import
import { isObjNotEmpty } from '@svizzle/utils';
// eslint-disable-next-line node/no-extraneous-import
import { capitalise } from 'svizzle/utils/string-string';

// import { makeIntermediateObj } from 'app/utils';
import { createFormStores } from './form.context';
import { formTemplate } from './form';
import { bindToStore } from '../utils';

const AXIS_NAMES = [
	'primary',
	'secondary',
	'tertiary',
	'quaternary',
	'quinary',
	'senary',
	'septenary',
	'octonary',
	'nonary',
	'denary'
];

function createForm (ctx, id, arrayIndex) {
	const machine = formTemplate.withContext({
		...ctx,
		id,
		arrayIndex,
		...createFormStores(),
	});
	const interpreter = spawn(machine, id);
	const newForm = {
		id,
		text: capitalise(id),
		value: arrayIndex,
		disabled: false,
		machine: bindToStore(interpreter),
	};
	// newForm.unsubscribe = spawned.subscribe(() => undefined);
	return newForm;
}

export function spawnNestedForm (ctx) {
	const forms = get(ctx.forms);
	const arrayIndex = forms.length;
	const selectedForm = get(ctx.selectedForm);
	if (!selectedForm || selectedForm.value + 1 === arrayIndex) {
		const nextName = AXIS_NAMES[arrayIndex];
		ctx.forms.set([
			...forms,
			createForm(ctx, nextName, arrayIndex)
		]);
	}
}

export function deleteNestedForms (ctx, event) {
	const forms = get(ctx.forms);
	let index = event.formId;
	if (typeof index !== 'number') {
		index = ctx.arrayIndex;
	}
	if (index === undefined) {
		return ctx;
	}
	const formsToStop = forms.slice(index + 1);
	formsToStop.forEach(f => f.machine.send('DISCARDED'));
	const newFormsArray = forms.slice(0, index + 1);
	ctx.forms.set(newFormsArray);
	return ctx;
}

export function selectForm (ctx, event) {
	const forms = get(ctx.forms);
	const form = event.form || forms[0];
	ctx.selectedForm.set(form);
	return ctx;
}

export function resetForms (ctx) {
	const forms = get(ctx.forms);
	forms.forEach(f => f.machine.send('DISCARDED'));
	// forms.forEach(f => f.unsubscribe());
	ctx.selectedForm.set(undefined);
	ctx.forms.set([]);
	ctx.dataset.set(null);
	return ctx;
}

export function parseParams (routeMachine, event) {
	routeMachine.send('TYPINGS_CHANGED', {
		datasetTypings: event.datasetTypings
	});
	routeMachine.send('FORM_ADDED');
	routeMachine.send('FORM_SELECTED');
	if (event.query) {
		const q = event.query;
		routeMachine.send('DATASET_CHANGED', {dataset: q.dataset});
		routeMachine.send('RESULT_SIZE_CHANGED', {resultSize: q.size});
		q.forms.forEach(form => {
			const forms2 = get(get(routeMachine).context.forms);
			const newForm = forms2[forms2.length - 1];
			newForm.text = capitalise(form.name);
			newForm.machine.send('RENAME', {
				name: form.name
			});
			routeMachine.send('FORM_SELECTED', {form: newForm})
			routeMachine.send('EDITED');
			if (!_.isNil(form.selection) && isObjNotEmpty(form.selection)) {
				newForm.machine.send('SELECTION_CHANGED', {
					selection: form.selection
				});
			}
			if (!_.isNil(form.params) && isObjNotEmpty(form.params)) {
				// routeMachine.send('FORM_SELECTED', {form: newForm})
				newForm.machine.send('QUERY_CHANGED',{
					params: form.params
				});
			}
		});
		const form = get(get(routeMachine).context.forms).find(f => f.id === q.form);
		if (!_.isNil(form)) {
			routeMachine.send('FORM_SELECTED', {form});
			routeMachine.send('EDITED');
		}
	}
}
