// eslint-disable-next-line node/no-unpublished-import
import * as _ from 'lamb';
// eslint-disable-next-line node/no-unpublished-import
import { get } from 'svelte/store';
// eslint-disable-next-line node/no-unpublished-import
import { spawn } from 'xstate';
// eslint-disable-next-line node/no-extraneous-import
import { capitalise } from 'svizzle/utils/string-string';
import { tapValue } from '@svizzle/dev';

import { makeIntermediateObj } from 'app/utils';
import { createFormStores } from './form.context';
import { createFormMachine } from './form';

const AXIS_NAMES = [
	'primary',
	'secondary',
	'tertiary',
	'quaternary',
	'quinary',
	'senary',
	'septenary',
	'octonary',
	'nonary',
	'denary'
];

function createForm (ctx, id, arrayIndex) {
	const {machine: formTemplate} = createFormMachine({
		...ctx,
		id,
		arrayIndex,
		...createFormStores(),
	});
	const spawned = spawn(formTemplate, id);
	const newForm = {
		name: id,
		text: capitalise(id),
		value: arrayIndex,
		disabled: false,
		machine: spawned,
	};
	newForm.unsubscribe = spawned.subscribe(() => undefined);
	return newForm;
}

export function spawnNestedForm (ctx) {
	const forms = get(ctx.forms);
	const arrayIndex = forms.length
	const selectedForm = get(ctx.selectedForm);
	if (!selectedForm || selectedForm.value + 1 === arrayIndex) {
		const nextName = AXIS_NAMES[arrayIndex];
		ctx.forms.set([
			...forms,
			createForm(ctx, nextName, arrayIndex)
		]);
	}
}

export function deleteNestedForms (ctx, event) {
	const forms = get(ctx.forms);
	const index = event.formId || ctx.arrayIndex;
	if (index === undefined) {
		return ctx;
	}
	const formsToStop = forms.slice(index + 1);
	formsToStop.forEach(f => f.unsubscribe());
	const newFormsArray = forms.slice(0, index + 1);
	ctx.forms.set(newFormsArray);
	return ctx;
}

export function selectForm (ctx, event) {
	const forms = get(ctx.forms);
	const form = event.form || forms[forms.length - 1];
	ctx.selectedForm.set(form);
	return ctx;
}

/*
const contextLoader = _.pipe([
	tapValue('loading'),
]);
*/
export function parseParams (ctx, event) {
	try {
		ctx.datasetTypings = event.datasetTypings;
		if (event.dataset) {
			ctx.dataset.set(event.dataset);
		}
		if (event.query) {
			const obj = makeIntermediateObj(event.query);
			ctx.resultSize.set(obj.size);
			const i = 0;
			obj.aggs.forEach(a => {
				const newForm = createForm(ctx, a.name, i);
				ctx.selectedForm.set(a.name);
				ctx.forms.set([
					...get(ctx.forms),
					newForm,
				]);
				newForm.machine.send('SELECTION_CHANGED', {
					selection: {
						aggregation: a.aggregation,
						field: a.field,
					}
				});
				newForm.machine.send('QUERY_CHANGED',{
					params: a.params
				})
			})
			//const result = contextLoader(ctx, obj);
		}
	} catch (e) {
		console.log('wupz',e);
	}

	return ctx;
}
