// eslint-disable-next-line node/no-unpublished-import
import { get } from 'svelte/store';
// eslint-disable-next-line node/no-unpublished-import
import { assign } from 'xstate';

import {
	aggregations,
	datasets,
	fields,
	types,
	fieldNames,
} from 'app/machines/builder/dictionaries';
import DATASETS from 'app/data/datasets.json';
import {
	metricLabels,
	bucketLabels,
} from 'app/elasticsearch/config';
import { spawnNestedForm, deleteNestedForms } from './_options';
import { request } from 'app/net';
import {
	getEndpointURL,
	getSchema
} from 'app/utils';
import { buildAggregation } from 'app/elasticsearch';
import { getCompletions } from 'app/tsservices';

function setSelection (ctx, event) {
	ctx.selection.set({
		...get(ctx.selection),
		...event.selection
	});
	if (event.dataset) {
		ctx.dataset.set(event.dataset);
	}
	return ctx;
}

const isMissing = (key, value) => obj => Boolean(obj)
	&& !obj[key].has(value);

function computeLists (ctx) {
	const nextSelection = get(ctx.selection);
	const dataset = get(ctx.dataset);
	const typeDicts = types[nextSelection.type];
	const fieldDicts = fields[nextSelection.field];
	const datasetDicts = dataset
		&& datasets[DATASETS[dataset].id];
	const aggDicts = aggregations[nextSelection.aggregation];

	ctx.bucketOptions.set(Object.keys(bucketLabels).map(agg => ({
		text: bucketLabels[agg],
		value: agg,
		disabled: [typeDicts, datasetDicts, fieldDicts]
		.some(isMissing('aggregations', agg))
	})));
	ctx.aggregatorOptions.set(Object.keys(metricLabels).map(agg => ({
		text: metricLabels[agg],
		value: agg,
		disabled: [typeDicts, datasetDicts, fieldDicts]
		.some(isMissing('aggregations', agg))
	})));
	ctx.typeOptions.set(Object.keys(types).map(type => ({
		text: type,
		value: type,
		disabled: false,
		effaced: [aggDicts, datasetDicts, fieldDicts]
		.some(isMissing('types', type))
	})));
	ctx.datasetOptions.set(DATASETS.map((dset, index) => ({
		text: dset.id,
		value: index,
		disabled: [typeDicts, fieldDicts, aggDicts]
		.some(isMissing('datasets', dset.id))
	})));
	ctx.fieldOptions.set(fieldNames.map(field => ({
		text: field,
		value: field,
		disabled:
			!dataset
			|| [typeDicts, datasetDicts, aggDicts]
			.some(isMissing('fields', field))
	})));
	return ctx;
}
let datasetTypings;
async function loadDSL () {
	if (!datasetTypings) {
		datasetTypings = await request(
			'GET',
			'dsl/datasets.ts',
			{type:'text'}
		);
	}
}

function computeTypings (ctx) {
	const dataset = get(ctx.dataset);
	// const datasetTypings = get(ctx.datasetTypings);
	if (window.ts) {
		const fieldInfo
			= getSchema(DATASETS[dataset])[ctx.selection.field];
		const agg = buildAggregation(
			ctx.selection.aggregation,
			ctx.selection.field,
			fieldInfo
		);
		const template = {
			[ctx.id]: {
				[ctx.selection.aggregation]: agg
			}
		};
		const ds = DATASETS[dataset].id;
		const code = `
			const selection: Aggs<${ds}, '${ctx.selection.field}'> =
				${JSON.stringify(template)};
		`;
		const fullCode = datasetTypings + code;
		const completions = getCompletions(
			fullCode,
			fullCode.lastIndexOf('{') + 1
		).sort((a, b) => b.required - a.required);
		ctx.completions = completions;
		ctx.selectedFieldCompletions.set(completions);
	}
	return ctx;
}

function computeRequestInternal (
	name,
	dataset,
	selection,
	params,
	completions,
	subaggs
) {
	const fieldInfo
		= getSchema(DATASETS[dataset])[selection.field];
	const agg = buildAggregation(
		selection.aggregation,
		selection.field,
		fieldInfo
	);
	const requestPart = {
		[selection.aggregation]: {
			...agg,
			...params
		}
	};
	if (subaggs) {
		requestPart.aggs = subaggs;
	}
	const query = {
		[name]: requestPart
	};
	// if (name !==)
	return {
		isRequiredSet: completions.every(c =>
			c.name === 'field'
			|| (!c.required
				|| params[c.name] !== undefined
				&& params[c.name] !== null
			)
		),
		query,
	};
}

function computeRequest (ctx, event) {
	ctx.readyForRequest.set(false);
	const selection = get(ctx.selection);
	const dataset = get(ctx.dataset);
	const completions = get(ctx.completions);
	const params = get(ctx.params);
	const computedRequest = computeRequestInternal(
		ctx.id,
		dataset,
		selection,
		params,
		completions,
		event.subaggs
	);
	ctx.computedQuery.set({
		size: get(ctx.resultSize),
		aggs: computeRequest.query
	});
	// TODO compute query from parents here
	ctx.readyForRequest.set(computedRequest.isRequiredSet);
	const endpoint = getEndpointURL(DATASETS[dataset]);
	ctx.url = `${endpoint}/_search`;
	ctx.cacheKey = `${ctx.url}/${JSON.stringify(get(ctx.computedQuery))}`;

	return ctx;
}

function setQuery (ctx, event) {
	// merge
	ctx.params = {
		...ctx.params,
		...event.params
	};
	// delete nulled parameters
	Object.keys(ctx.params).forEach(k => {
		ctx.params[k] === null && delete ctx.params[k]
	});
	if (event.resultSize) {
		ctx.resultSize.set(event.resultSize);
		console.log('setting size')
	}
	return ctx;
}

function clearTypings (ctx) {
	ctx.completions.set([]);
}

function clearQueryParams (ctx) {
	ctx.params = {};
	return ctx;
}

const cache = {};
function doQuery (ctx) {
	ctx.response.set(null);
	return request('POST', ctx.url, {data: get(ctx.query)});
}

function isInCache (ctx) {
	return ctx.cacheKey in cache;
}

function loadFromCache (ctx) {
	ctx.response.set(cache[ctx.cacheKey]);
	return ctx;
}

function storeInCache (ctx, event) {
	cache[ctx.cacheKey] = event.data;
	return ctx;
}

function setResponse (ctx, event) {
	ctx.response.set(event.data)
	return ctx;
}

export const formOptions = {
	actions: {
		/**
		 * Updates stores to reflect current aggregation parts selection
		 */
		setSelection: assign(setSelection),
		/**
		 * Creates a new form for configuring a subaggregation
		 */
		spawnNestedForm: assign(spawnNestedForm),
		/**
		 * Compute the lists of selectable choices for configuring the query.
		 */
		computeLists: assign(computeLists),
		// activateForm: ctx => console.log('activating')
		computeTypings: assign(computeTypings),
		computeRequest: assign(computeRequest),
		setQuery: assign(setQuery),
		clearTypings: assign(clearTypings),
		clearQueryParams: assign(clearQueryParams),
		loadDSL: assign(loadDSL),
		setResponse: assign(setResponse),
		storeInCache: assign(storeInCache),
		loadFromCache: assign(loadFromCache),
		deleteNestedForms: assign(deleteNestedForms),
		/*
		log: (ctx, event) => {
			console.log('logging form', ctx, event)
		}
		*/
	},
	guards: {
		isAutoExecute: ctx => get(ctx.runQueryOnSelect),
		isInCache,
		isMatching: () => false,
		isSelectionComplete: ({selection}) => {
			// console.log('guard', selection)
			return selection.aggregation !== null
				&& selection.dataset !== null
				&& selection.field !== null;
		},
		isQueryReady: ctx => get(ctx.readyForRequest)
	},
	services: {
		apiRequest: ctx => doQuery(ctx)
	}
};
