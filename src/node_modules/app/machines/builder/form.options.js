// eslint-disable-next-line node/no-unpublished-import
import { get } from 'svelte/store';
// eslint-disable-next-line node/no-unpublished-import
import { assign } from 'xstate';

import {
	aggregations,
	datasets,
	fields,
	types,
	fieldNames,
} from 'app/machines/builder/dictionaries';
import DATASETS from 'app/data/datasets.json';
import {
	metricLabels,
	bucketLabels,
} from 'app/elasticsearch/config';
import { spawnNestedForm } from './_options';
import { request } from 'app/net';
import {
	getEndpointURL,
	getSchema
} from 'app/utils';
import { buildAggregation } from 'app/elasticsearch';
import { getCompletions } from 'app/tsservices';

const isFormActive = ctx => ctx.id === get(ctx.selectedForm).name;

function setSelection (ctx, event) {
	ctx.selection = {
		...ctx.selection,
		...event.selection
	};
	ctx.activeSelection.set({
		...get(ctx.activeSelection),
		...event.activeSelection
	});
	if (isFormActive(ctx)) {
		ctx.activeSelection.set({
			...get(ctx.activeSelection),
			...ctx.selection
		})
	}
	return ctx;
}

const isMissing = (key, value) => obj => Boolean(obj)
	&& !obj[key].has(value);

function computeLists (ctx) {
	const nextSelection = get(ctx.activeSelection);
	const typeDicts = types[nextSelection.type];
	const fieldDicts = fields[nextSelection.field];
	const datasetDicts = nextSelection.dataset
		&& datasets[DATASETS[nextSelection.dataset].id];
	const aggDicts = aggregations[nextSelection.aggregation];

	ctx.bucketOptions.set(Object.keys(bucketLabels).map(agg => ({
		text: bucketLabels[agg],
		value: agg,
		disabled: [typeDicts, datasetDicts, fieldDicts]
		.some(isMissing('aggregations', agg))
	})));
	ctx.aggregatorOptions.set(Object.keys(metricLabels).map(agg => ({
		text: metricLabels[agg],
		value: agg,
		disabled: [typeDicts, datasetDicts, fieldDicts]
		.some(isMissing('aggregations', agg))
	})));
	ctx.typeOptions.set(Object.keys(types).map(type => ({
		text: type,
		value: type,
		disabled: false,
		effaced: [aggDicts, datasetDicts, fieldDicts]
		.some(isMissing('types', type))
	})));
	ctx.datasetOptions.set(DATASETS.map((dataset, index) => ({
		text: dataset.id,
		value: index,
		disabled: [typeDicts, fieldDicts, aggDicts]
		.some(isMissing('datasets', dataset.id))
	})));
	ctx.fieldOptions.set(fieldNames.map(field => ({
		text: field,
		value: field,
		disabled:
			!nextSelection.dataset
			|| [typeDicts, datasetDicts, aggDicts]
			.some(isMissing('fields', field))
	})));
	return ctx;
}
let datasetTypings;
async function loadDSL () {
	if (!datasetTypings) {
		datasetTypings = await request(
			'GET',
			'dsl/datasets.ts',
			{type:'text'}
		);
	}
}

function computeTypings (ctx) {
	const selectedDataset = get(ctx.activeSelection).dataset;
	// const datasetTypings = get(ctx.datasetTypings);
	if (window.ts) {
		const fieldInfo
			= getSchema(DATASETS[selectedDataset])[ctx.selection.field];
		const agg = buildAggregation(
			ctx.selection.aggregation,
			ctx.selection.field,
			fieldInfo
		);
		const template = {
			[ctx.id]: {
				[ctx.selection.aggregation]: agg
			}
		};
		const ds = DATASETS[selectedDataset].id;
		const code = `
			const selection: Aggs<${ds}, '${ctx.selection.field}'> =
				${JSON.stringify(template)};
		`;
		const fullCode = datasetTypings + code;
		const completions = getCompletions(
			fullCode,
			fullCode.lastIndexOf('{') + 1
		).sort((a, b) => b.required - a.required);
		ctx.selectedFieldCompletions.set(completions);
	}
	return ctx;
}

function computeRequest (ctx) {
	ctx.readyForRequest.set(false);
	const selectedDataset = get(ctx.activeSelection).dataset;
	const fieldInfo
		= getSchema(DATASETS[selectedDataset])[ctx.selection.field];
	const agg = buildAggregation(
		ctx.selection.aggregation,
		ctx.selection.field,
		fieldInfo
	);
	ctx.query = {
		[ctx.id]: {
			[ctx.selection.aggregation]: {
				...agg,
				...ctx.params
			}
		}
	};

	// TODO compute query from parents here
	if (isFormActive(ctx)) {
		ctx.activeParams.set(ctx.params);
		ctx.activeQuery.set({
			size: get(ctx.resultSize),
			aggs: ctx.query
		});
		const completions = get(ctx.selectedFieldCompletions);
		const isRequiredSet = completions.every(c =>
			c.name === 'field'
			|| (!c.required
				|| ctx.params[c.name] !== undefined
				&& ctx.params[c.name] !== null
			)
		);
		ctx.readyForRequest.set(isRequiredSet);
		const endpoint = getEndpointURL(DATASETS[selectedDataset]);
		ctx.url = `${endpoint}/_search`;
		ctx.cacheKey = `${ctx.url}/${JSON.stringify(get(ctx.activeQuery))}`;
	}
	// currentTemplate.aggs = {...currentParams.output};
	// currentTemplate = currentTemplate.aggs[currentName];

	return ctx;
}

function setQuery (ctx, event) {
	// merge
	ctx.params = {
		...ctx.params,
		...event.params
	};
	// delete nulled parameters
	Object.keys(ctx.params).forEach(k => {
		ctx.params[k] === null && delete ctx.params[k]
	});
	if (event.resultSize) {
		ctx.resultSize.set(event.resultSize);
		console.log('setting size')
	}
	return ctx;
}

function clearTypings (ctx) {
	ctx.selectedFieldCompletions.set([]);
}

function clearQueryParams (ctx) {
	ctx.params = {};
	return ctx;
}

const activateForm = ctx => {
	const s = {...ctx.selection};
	delete s.dataset;
	ctx.activeSelection.update(as => ({
		...as,
		...s
	}));
	return ctx;
	// console.log('active selection set')
}

const cache = {};
function doQuery (ctx) {
	ctx.response.set(null);
	return request('POST', ctx.url, {data: get(ctx.activeQuery)});
}

function isInCache (ctx) {
	return ctx.cacheKey in cache;
}

function loadFromCache (ctx) {
	ctx.response.set(cache[ctx.cacheKey]);
	return ctx;
}

function storeInCache (ctx, event) {
	cache[ctx.cacheKey] = event.data;
	return ctx;
}

function setResponse (ctx, event) {
	ctx.response.set(event.data)
	return ctx;
}

export const formOptions = {
	actions: {
		/**
		 * Updates stores to reflect current aggregation parts selection
		 */
		setSelection: assign(setSelection),
		/**
		 * Creates a new form for configuring a subaggregation
		 */
		spawnNestedForm: assign(spawnNestedForm),
		/**
		 * Compute the lists of selectable choices for configuring the query.
		 */
		computeLists: assign(computeLists),
		// activateForm: ctx => console.log('activating')
		activateForm: assign(activateForm),
		computeTypings: assign(computeTypings),
		computeRequest: assign(computeRequest),
		setQuery: assign(setQuery),
		clearTypings: assign(clearTypings),
		clearQueryParams: assign(clearQueryParams),
		loadDSL: assign(loadDSL),
		setResponse: assign(setResponse),
		storeInCache: assign(storeInCache),
		loadFromCache: assign(loadFromCache),
		/*
		log: (ctx, event) => {
			console.log('logging form', ctx, event)
		}
		*/
	},
	guards: {
		isAutoExecute: ctx => get(ctx.runQueryOnSelect),
		isInCache,
		isMatching: () => false,
		isSelectionComplete: ({selection}) => {
			// console.log('guard', selection)
			return selection.aggregation !== null
				&& selection.dataset !== null
				&& selection.field !== null;
		},
		isQueryReady: ctx => get(ctx.readyForRequest)
	},
	services: {
		apiRequest: ctx => doQuery(ctx)
	}
};
