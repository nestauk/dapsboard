/* eslint-disable node/no-unpublished-import */
import { get } from 'svelte/store';
import { assign, sendParent } from 'xstate';

import {
	aggregations,
	datasets,
	fields,
	types,
	fieldNames,
} from 'app/machines/builder/dictionaries';
import DATASETS from 'app/data/datasets.json';
import {
	metricLabels,
	bucketLabels,
} from 'app/elasticsearch/config';
import { deleteNestedForms } from './_options';
import { request } from 'app/net';
import {
	getEndpointURL,
	getSchema
} from 'app/utils';
import { buildAggregation } from 'app/elasticsearch';
import { getCompletions } from 'app/tsservices';

function setSelection (ctx, event) {
	ctx.selection.set({
		...get(ctx.selection),
		...event.selection
	});
	if (event.dataset !== undefined) {
		ctx.dataset.set(event.dataset);
	}
	return ctx;
}

const isMissing = (key, value) => obj => Boolean(obj)
	&& !obj[key].has(value);

function computeLists (ctx) {
	const nextSelection = get(ctx.selection);
	const dataset = get(ctx.dataset);
	const typeDicts = types[nextSelection.type];
	const fieldDicts = fields[nextSelection.field];
	const datasetDicts = datasets[dataset];
	const aggDicts = aggregations[nextSelection.aggregation];

	ctx.bucketOptions.set(Object.keys(bucketLabels).map(agg => ({
		text: bucketLabels[agg],
		value: agg,
		disabled: [typeDicts, datasetDicts, fieldDicts]
		.some(isMissing('aggregations', agg))
	})));
	ctx.metricOptions.set(Object.keys(metricLabels).map(agg => ({
		text: metricLabels[agg],
		value: agg,
		disabled: [typeDicts, datasetDicts, fieldDicts]
		.some(isMissing('aggregations', agg))
	})));
	ctx.typeOptions.set(Object.keys(types).map(type => ({
		text: type,
		value: type,
		disabled: false,
		effaced: [aggDicts, datasetDicts, fieldDicts]
		.some(isMissing('types', type))
	})));
	ctx.datasetOptions.set(DATASETS.map(dset => ({
		text: dset.id,
		value: dset.id,
		disabled: [typeDicts, fieldDicts, aggDicts]
		.some(isMissing('datasets', dset.id))
	})));
	ctx.fieldOptions.set(fieldNames.map(field => ({
		text: field,
		value: field,
		disabled:
			!dataset
			|| [typeDicts, datasetDicts, aggDicts]
			.some(isMissing('fields', field))
	})));
	return ctx;
}

function computeTypings (ctx) {
	const selection = get(ctx.selection)
	const dataset = get(ctx.dataset);
	if (window.ts) {
		const dset = DATASETS.find(ds => dataset === ds.id);
		const fieldInfo = getSchema(dset)[selection.field];
		const agg = buildAggregation(
			selection.aggregation,
			selection.field,
			fieldInfo
		);
		const template = {
			[ctx.id]: {
				[selection.aggregation]: agg
			}
		};
		const code = `
			const selection: Aggs<${dataset}, '${selection.field}'> =
				${JSON.stringify(template)};
		`;
		const fullCode = ctx.datasetTypings + code;
		const completions = getCompletions(
			fullCode,
			fullCode.lastIndexOf('{') + 1
		).sort((a, b) => b.required - a.required);
		ctx.completions.set(completions);
	}
	return ctx;
}

function computeRequestInternal (
	ctx,
	arrayIndex,
	dataset,
	subresults
) {
	const form = get(ctx.forms)[arrayIndex];
	const machine = get(form.machine);

	const name = machine.context.id;
	const selection = get(machine.context.selection);
	const extendedParams = get(machine.context.params);
	const completions = get(machine.context.completions);

	const dset = DATASETS.find(ds => dataset === ds.id)
	const fieldInfo = getSchema(dset)[selection.field];

	const basicParams = buildAggregation(
		selection.aggregation,
		selection.field,
		fieldInfo
	);
	const agg = {
		[selection.aggregation]: {
			...basicParams,
			...extendedParams
		}
	};
	let isRequiredSet = true;
	if (subresults) {
		agg.aggs = subresults.query;
		isRequiredSet = isRequiredSet && subresults.isRequiredSet;
	}
	const query = {
		[name]: agg
	};
	const result = {
		isRequiredSet: isRequiredSet && completions.every(c =>
			c.name === 'field'
			|| (!c.required
				|| extendedParams[c.name] !== undefined
				&& extendedParams[c.name] !== null
			)
		),
		query,
	};
	if (arrayIndex === 0) {
		return result;
	}
	return computeRequestInternal(
		ctx,
		arrayIndex - 1,
		dataset,
		result
	);
}

function computeRequest (ctx) {
	ctx.readyForRequest.set(false);
	const dataset = get(ctx.dataset);
	const result = computeRequestInternal(
		ctx,
		ctx.arrayIndex,
		dataset
	);
	const requestBody = {
		size: get(ctx.resultSize),
		aggs: result.query
	};
	ctx.computedQuery.set(requestBody);
	ctx.readyForRequest.set(result.isRequiredSet);
	const endpoint = getEndpointURL(DATASETS.find(ds => dataset === ds.id));
	ctx.url = `${endpoint}/_search`;

	return ctx;
}

function getQuery (ctx) {
	const cQuery = get(ctx.computedQuery);
	const pQuery = get(ctx.parsedQuery);
	return get(ctx.selectedRequestTab) === 'fields'
		? cQuery
		: pQuery || cQuery;
}

function computeCacheKey (ctx) {
	ctx.cacheKey = `${ctx.url}/${JSON.stringify(getQuery(ctx))}`;
	return ctx;
}

function setQuery (ctx, event) {
	// merge
	const params = {
		...get(ctx.params),
		...event.params
	};
	// delete nulled parameters
	Object.keys(params).forEach(k => {
		params[k] === null && delete params[k]
	});
	ctx.params.set(params);
	if (event.resultSize !== undefined) {
		ctx.resultSize.set(event.resultSize);
	}
	return ctx;
}

function setJSON (ctx, event) {
	ctx.parsedQuery.set(event.json);
	return ctx;
}

function clearTypings (ctx) {
	ctx.completions.set([]);
	return ctx;
}

function clearQuery (ctx) {
	ctx.params.set({});
	ctx.computedQuery.set({});
	return ctx;
}

// Storing the cache globally as it can be shared safely among instances.
const cache = {};
function doQuery (ctx) {
	ctx.response.set(null);
	return request('POST', ctx.url, {data: getQuery(ctx)});
}

function isInCache (ctx) {
	return ctx.cacheKey in cache;
}

function isMatching (ctx) {
	return ctx.cacheKey === `${ctx.url}/${JSON.stringify(getQuery(ctx))}`;
}

function loadFromCache (ctx) {
	ctx.response.set(cache[ctx.cacheKey]);
	return ctx;
}

function storeInCache (ctx, event) {
	cache[ctx.cacheKey] = event.data;
	return ctx;
}

function setResponse (ctx, event) {
	ctx.response.set(event.data)
	return ctx;
}

function rename (ctx, event) {
	const newName = event.name;
	ctx.id = newName;
}

export const formOptions = {
	actions: {
		/**
		 * Updates stores to reflect current aggregation parts selection.
		 */
		setSelection: assign(setSelection),
		/**
		 * Creates a new form for configuring a subaggregation.
		 */
		spawnNestedForm: sendParent('FORM_ADDED'),
		/**
		 * Compute the lists of selectable choices for configuring the query.
		 */
		computeLists: assign(computeLists),
		/**
		 * Compute the property types for the currently configured query.
		 */
		computeTypings: assign(computeTypings),
		/**
		 * Compute the request body.
		 */
		computeRequest: assign(computeRequest),
		/**
		 * Compute a unique key for storing query responses in the cache.
		 */
		computeCacheKey: assign(computeCacheKey),
		/**
		 * Store changes in input values in the context.
		 */
		setQuery: assign(setQuery),
		/**
		 * Reset the types for form inputs if the query configuration changes.
		 */
		clearTypings: assign(clearTypings),
		/**
		 * Clear the input values if the query configuration changes.
		 */
		clearQuery: assign(clearQuery),
		/**
		 * Store the response in the context.
		 */
		setResponse: assign(setResponse),
		/**
		 * Store the response in the cache.
		 */
		storeInCache: assign(storeInCache),
		/**
		 * Load a query from the cache.
		 */
		loadFromCache: assign(loadFromCache),
		/**
		 * Delete nested forms if the configuration becomnes invalid.
		 */
		deleteNestedForms: assign(deleteNestedForms),
		/**
		 * Directly edit the query JSON to be requested.
		 */
		setJSON: assign(setJSON),
		/**
		 * Rename the form.
		 */
		rename: assign(rename),
		/**
		 * Notifies parent that query was requested.
		 */
		sendCommitted: sendParent(ctx => ({
			type: 'COMMITTED',
			formId: ctx.id
		}), {delay: 1}),
		/**
		 * Notifies parent that query was requested.
		 */
		sendEdited: sendParent('EDITED'),
	},
	guards: {
		isAutoExecute: ctx => get(ctx.runQueryOnSelect),
		isInCache,
		isMatching,
		isSelectionComplete: ({selection, dataset}) => {
			const sel = get(selection);
			return sel.aggregation !== null
				&& get(dataset) !== null
				&& sel.field !== null;
		},
		isQueryReady: ctx => get(ctx.readyForRequest),
	},
	services: {
		apiRequest: ctx => doQuery(ctx),
	}
};
