import {get} from 'svelte/store';
import {assign, sendParent} from 'xstate';
import {isNotNull, isNotNil} from '@svizzle/utils';

import {
	aggregations,
	datasets,
	fields,
	types,
	fieldNames,
} from 'app/machines/builder/dictionaries';
import DATASETS from 'app/data/datasets.json';
import {
	metricLabels,
	metricMultiFieldLabels,
	topBucketLabels,
	bucketLabels,
	bucketMultiFieldLabels,
	nestedBucketLabels
} from 'app/elasticsearch/config/aggsLabels';
import {request} from 'app/utils/net';
import {getESType, getSchema, getSearchURL} from 'app/utils/specs';
import {
	getAggParamDefaultValue,
	getParamsByAgg,
} from 'app/elasticsearch/utils/aggParams';
import {buildAggregation} from 'app/elasticsearch/utils/aggQuery';

function setSelection (ctx, event) {
	ctx.selection.set({
		...get(ctx.selection),
		...event.selection
	});
	if ('dataset' in event) {
		ctx.dataset.set(event.dataset);
	}
	return ctx;
}

const isMissing = (key, value) => obj => Boolean(obj)
	&& !obj[key].has(value);

const isTopLevel = ctx => ctx.arrayIndex === 0

function computeLists (ctx) {
	const nextSelection = get(ctx.selection);
	const dataset = get(ctx.dataset);
	const typeDicts = types[nextSelection.type];
	const fieldDicts = fields[nextSelection.field];
	const datasetDicts = datasets[dataset];
	const aggDicts = aggregations[nextSelection.aggregation];

	ctx.topBucketOptions.set(Object.keys(topBucketLabels).map(agg => ({
		text: topBucketLabels[agg],
		value: agg,
		disabled:
			[typeDicts, datasetDicts, fieldDicts]
			.some(isMissing('aggregations', agg))
			|| !isTopLevel(ctx)
	})));
	ctx.bucketOptions.set(Object.keys(bucketLabels).map(agg => ({
		text: bucketLabels[agg],
		value: agg,
		disabled:
			[typeDicts, datasetDicts, fieldDicts]
			.some(isMissing('aggregations', agg))
	})));
	ctx.bucketMultiFieldOptions.set(Object.keys(bucketMultiFieldLabels).map(agg => ({
		text: bucketMultiFieldLabels[agg],
		value: agg,
		disabled:
			[typeDicts, datasetDicts, fieldDicts]
			.some(isMissing('aggregations', agg))
	})));
	ctx.nestedBucketOptions.set(Object.keys(nestedBucketLabels).map(agg => ({
		text: nestedBucketLabels[agg],
		value: agg,
		disabled:
			[typeDicts, datasetDicts, fieldDicts]
			.some(isMissing('aggregations', agg))
			|| isTopLevel(ctx)
	})));
	ctx.metricOptions.set(Object.keys(metricLabels).map(agg => ({
		text: metricLabels[agg],
		value: agg,
		disabled:
			[typeDicts, datasetDicts, fieldDicts]
			.some(isMissing('aggregations', agg))
	})));
	ctx.metricMultiFieldOptions.set(Object.keys(metricMultiFieldLabels).map(agg => ({
		text: metricMultiFieldLabels[agg],
		value: agg,
		disabled:
			[typeDicts, datasetDicts, fieldDicts]
			.some(isMissing('aggregations', agg))
	})));
	ctx.typeOptions.set(Object.keys(types).map(type => ({
		text: type,
		value: type,
		disabled: false,
		effaced:
			[aggDicts, datasetDicts, fieldDicts]
			.some(isMissing('types', type))
	})));
	ctx.datasetOptions.set(DATASETS.map(dset => ({
		text: dset.id,
		value: dset.id,
		disabled:
			[typeDicts, fieldDicts, aggDicts]
			.some(isMissing('datasets', dset.id))
	})));
	ctx.fieldOptions.set(fieldNames.map(field => ({
		text: field,
		value: field,
		disabled:
			!dataset
			|| [typeDicts, datasetDicts, aggDicts]
			.some(isMissing('fields', field))
	})));
	return ctx;
}

function computeTypings (ctx) {
	const selection = get(ctx.selection)
	const dataset = get(ctx.dataset);

	const dset = DATASETS.find(ds => dataset === ds.id)
	const fieldInfo = getSchema(dset)[selection.field];
	const fieldType = getESType(fieldInfo);
	const params = getParamsByAgg(selection.aggregation, fieldType);
	ctx.completions.set(params);

	return ctx;
}

function computeDefaultValues (ctx) {
	const selection = get(ctx.selection)
	const dataset = get(ctx.dataset);
	const completions = get(ctx.completions);
	const defaultValues = {};
	completions.forEach(c => {
		const value = getAggParamDefaultValue(
			selection.aggregation,
			dataset,
			selection.field,
			c.displayText,
			c.name
		);
		if (isNotNil(value)) {
			defaultValues[c.name] =  value;
		}
	})
	ctx.defaultValues.set(defaultValues);
	if (!get(ctx.isParsing)) {
		ctx.params.set({
			...defaultValues,
			...get(ctx.params)
		});
	}
}

function computeRequestInternal (
	ctx,
	arrayIndex,
	dataset,
	subresults
) {
	const form = get(ctx.forms)[arrayIndex];
	const machine = get(form.machine);

	const name = machine.context.id;
	const selection = get(machine.context.selection);
	const extendedParams = get(machine.context.params);
	const completions = get(machine.context.completions);

	const dset = DATASETS.find(ds => dataset === ds.id)
	const fieldInfo = getSchema(dset)[selection.field];

	const basicParams = buildAggregation(
		selection.aggregation,
		selection.field,
		fieldInfo
	);
	const computedParams = {
		...basicParams,
		...extendedParams
	};
	const agg = {
		[selection.aggregation]: computedParams
	};

	let isRequiredSet = true;
	if (subresults) {
		agg.aggs = subresults.query;
		isRequiredSet = isRequiredSet && subresults.isRequiredSet;
	}
	isRequiredSet = isRequiredSet && completions.every(c => {
		const params = extendedParams[c.name];
		return c.name === 'field'
			|| !c.required
			|| !c.name.startsWith('__')
			&& isNotNil(params)
			|| c.name.startsWith('__')
			&& isNotNil(params?.[params?.__type])
	});
	Object.keys(computedParams).forEach(paramName => {
		if (paramName.startsWith('__')) {
			const fieldName = computedParams[paramName].__type;
			computedParams[fieldName] = computedParams[paramName][fieldName];
			delete computedParams[paramName];
		}
	})
	const query = {
		[name]: agg
	};
	const result = {
		isRequiredSet,
		query,
	};
	if (arrayIndex === 0) {
		return result;
	}
	return computeRequestInternal(
		ctx,
		arrayIndex - 1,
		dataset,
		result
	);
}

function computeRequest (ctx) {
	ctx.readyForRequest.set(false);
	const dataset = get(ctx.dataset);
	const result = computeRequestInternal(
		ctx,
		ctx.arrayIndex,
		dataset
	);
	const requestBody = {
		size: get(ctx.resultSize),
		aggs: result.query
	};
	ctx.computedQuery.set(requestBody);
	ctx.readyForRequest.set(result.isRequiredSet);
	ctx.url = getSearchURL(DATASETS.find(ds => dataset === ds.id));

	return ctx;
}

function getQuery (ctx) {
	const cQuery = get(ctx.computedQuery);
	const pQuery = get(ctx.parsedQuery);
	return get(ctx.selectedRequestTab) === 'fields'
		? cQuery
		: pQuery || cQuery;
}

function computeCacheKey (ctx) {
	ctx.cacheKey = `${ctx.url}/${JSON.stringify(getQuery(ctx))}`;
	return ctx;
}

function setQuery (ctx, event) {
	// merge
	const params = {
		...get(ctx.params),
		...event.params
	};
	// delete nulled parameters
	Object.keys(params).forEach(k => {
		params[k] === null && delete params[k];
		if (typeof params[k] === 'object') {
			Object.keys(params[k]).forEach(k2 => {
				params[k][k2] === null && delete params[k][k2];
			});
		}
	});
	ctx.params.set(params);
	if (isNotNil(event.resultSize)) {
		ctx.resultSize.set(event.resultSize);
	}
	return ctx;
}

function setJSON (ctx, event) {
	ctx.parsedQuery.set(event.json);
	return ctx;
}

function clearTypings (ctx) {
	ctx.completions.set([]);
	return ctx;
}

function clearQuery (ctx) {
	ctx.params.set({});
	ctx.computedQuery.set({});
	return ctx;
}

// Storing the cache globally as it can be shared safely among instances.
const cache = {};
function doQuery (ctx) {
	ctx.response.set(null);
	ctx.responseStatus.set({
		pending: true,
		matching: false,
		error: false
	});
	return request('POST', ctx.url, {data: getQuery(ctx)});
}

function isInCache (ctx) {
	return ctx.cacheKey in cache;
}

function isMatching (ctx) {
	return ctx.cacheKey === `${ctx.url}/${JSON.stringify(getQuery(ctx))}`;
}

function loadFromCache (ctx) {
	ctx.response.set(cache[ctx.cacheKey]);
	return ctx;
}

function storeInCache (ctx, event) {
	cache[ctx.cacheKey] = event.data;
	return ctx;
}

function setErrorStatus (ctx) {
	ctx.responseStatus.set({
		pending: false,
		matching: false,
		error: true
	});
	return ctx;
}
function setResponse (ctx, event) {
	ctx.response.set(event.data)
	ctx.responseStatus.set({
		pending: false,
		matching: true,
		error: false
	});
	return ctx;
}

function rename (ctx, event) {
	const newName = event.name;
	ctx.id = newName;
}

function getError (ctx, event) {
	ctx.response.set(event.data.jsonMessage)
}

export const formOptions = {
	actions: {
		/**
		 * Clear the input values if the query configuration changes.
		 */
		clearQuery: assign(clearQuery),
		/**
		 * Reset the types for form inputs if the query configuration changes.
		 */
		clearTypings: assign(clearTypings),
		/**
		 * Compute default values for the current selection.
		 */
		computeDefaultValues: assign(computeDefaultValues),
		/**
		 * Compute the lists of selectable choices for configuring the query.
		 */
		computeLists: assign(computeLists),
		/**
		 * Compute a unique key for storing query responses in the cache.
		 */
		computeCacheKey: assign(computeCacheKey),
		/**
		 * Compute the request body.
		 */
		computeRequest: assign(computeRequest),
		/**
		 * Compute the property types for the currently configured query.
		 */
		computeTypings: assign(computeTypings),
		getError: assign(getError),
		/**
		 * Load a query from the cache.
		 */
		loadFromCache: assign(loadFromCache),
		/**
		 * Rename the form.
		 */
		rename: assign(rename),
		/**
		 * Notifies parent that query was requested.
		 */
		sendCommitted: sendParent(ctx => ({
			type: 'COMMITTED',
			formId: ctx.id
		}), {delay: 1}),
		/**
		 * Notifies parent that query was requested.
		 */
		sendEdited: sendParent('EDITED'),
		/**
		 * Notifies sub aggregation that the tree has changed
		 */
		sendFormChanged: sendParent(ctx => ({
			type: 'FORM_CHANGED',
			formId: ctx.id
		})),
		/**
		 * Creates a new form for configuring a subaggregation.
		 */
		sendSelectionComplete: sendParent(ctx => ({
			type: 'SELECTION_COMPLETED',
			formId: ctx.id,
			selection: get(ctx.selection)
		})),
		/**
		 * Notify the parent that the selection is now incomplete
		 */
		sendSelectionIncomplete: sendParent(ctx => ({
			type: 'SELECTION_INCOMPLETE',
			formId: ctx.id,
		})),
		/**
		 * Set the response status to error.
		 */
		setErrorStatus: assign(setErrorStatus),
		/**
		 * Directly edit the query JSON to be requested.
		 */
		setJSON: assign(setJSON),
		/**
		 * Store changes in input values in the context.
		 */
		setQuery: assign(setQuery),
		/**
		 * Store the response in the context.
		 */
		setResponse: assign(setResponse),
		/**
		 * Updates stores to reflect current aggregation parts selection.
		 */
		setSelection: assign(setSelection),
		/**
		 * Store the response in the cache.
		 */
		storeInCache: assign(storeInCache),
	},
	guards: {
		isAutoExecute: ctx => get(ctx.runQueryOnSelect),
		isInCache,
		isMatching,
		isQueryReady: ctx => get(ctx.readyForRequest),
		isSelectionComplete: ({selection, dataset}) => {
			const sel = get(selection);
			return isNotNull(sel.aggregation)
				&& isNotNull(get(dataset))
				&& isNotNull(sel.field);
		},
	},
	services: {
		apiRequest: ctx => doQuery(ctx),
	}
};
