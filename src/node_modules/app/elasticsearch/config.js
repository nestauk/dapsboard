export const metricLabels = {
	// boxplot: 'BoxPlot',
	// matrix_stats: 'Matrix Stats',
	// median_absolute_deviation: 'Median Absolute Deviation' // >= 6.6
	// scripted_metric: 'Scripted Metric',
	// string_stats: 'String Statistics',
	// string_stats: 'String Stats' // >= 7.6
	avg: 'Average',
	cardinality: 'Cardinality',
	extended_stats: 'Extended Statistics',
	geo_bounds: 'Geographic Bounds',
	geo_centroid: 'Geographic Centroid',
	max: 'Maximum',
	median_absolute_deviation: 'Median Abs. Dev.',
	min: 'Minimum',
	percentile_ranks: 'Percentile Ranks',
	percentiles: 'Percentiles',
	stats: 'Statistics',
	sum: 'Sum',
	top_hits: 'Top Hits',
	value_count: 'Value Count'
}

export const metricMultiFieldLabels = {
	weighted_avg: 'Weighted Average'
}

export const topBucketLabels = {
	global: 'Global'
}

export const bucketLabels = {
	// auto_date_histogram: 'Auto Date Histogram' // >= 6.5
	// children: 'Children',
	auto_date_histogram: 'Auto Date Histogram',
	date_histogram: 'Date Histogram',
	date_range: 'Date Range',
	geo_distance: 'Geo Distance',
	geohash_grid: 'Geo Hash',
	histogram: 'Histogram',
	ip_ranges: 'IP Ranges',
	missing: 'Missing',
	nested: 'Nested',
	range: 'Range',
	rare_terms: 'Rare Terms',
	sampler: 'Sampler',
	significant_terms: 'Significant Terms',
	significant_text: 'Significant Text',
	terms: 'Terms',
}

export const bucketMultiFieldLabels = {
	composite: 'Composite',
	filter: 'Filter',
	filters: 'Filters',
}

export const nestedBucketLabels = {
	diversified_sampler: 'Diversified Sampler',
	reverse_nested: 'Reverse Nested',
}

export const aggsByType = {
	boolean: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'missing',
		'nested',
		'reverse_nested',
		'sampler',
		'value_count',
		// 'percentiles',
		// 'percentile_ranks',
	],
	date: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash_time: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash_T_time: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	ES_geo_point_obj: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'geo_bounds',
		'geo_centroid',
		'geo_distance',
		'geohash_grid',
		'missing',
		'nested',
		'reverse_nested',
		'sampler',
		'value_count',
	],
	ES_keyword: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	'ES_keyword[]': [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	ES_text_w_keyword: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	'ES_text_w_keyword[]': [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'reverse_nested',
		'rare_terms',
		'sampler',
		'significant_terms',
		'significant_text',
		'text',
		'terms',
		'value_count',
	],
	float: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'histogram',
		'max',
		'matrix_stats',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'percentiles',
		'percentile_ranks',
		'reverse_nested',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	integer: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'histogram',
		'max',
		'matrix_stats',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'percentiles',
		'percentile_ranks',
		'reverse_nested',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	object: []
}

export const AGG_DOC_URLS = {
	avg: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-avg-aggregation.html',
	cardinality: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-cardinality-aggregation.html',
	extended_stats: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-extendedstats-aggregation.html',
	geo_bounds: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-geobounds-aggregation.html',
	geo_centroid: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-geocentroid-aggregation.html',
	max: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-max-aggregation.html',
	median_absolute_deviation: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-median-absolute-deviation-aggregation.html',
	min: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-min-aggregation.html',
	percentiles: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-percentile-aggregation.html',
	percentile_ranks: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-percentile-rank-aggregation.html',
	scripted_metric: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-scripted-metric-aggregation.html',
	stats: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-stats-aggregation.html',
	sum: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-sum-aggregation.html',
	top_hits: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-top-hits-aggregation.html',
	value_count: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-valuecount-aggregation.html',
	weighted_avg: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-weight-avg-aggregation.html',

	adjacency_matrix: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-adjacency-matrix-aggregation.html',
	auto_date_histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-autodatehistogram-aggregation.html',
	children: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-children-aggregation.html',
	composite: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-composite-aggregation.html',
	date_histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-datehistogram-aggregation.html',
	date_range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-daterange-aggregation.html',
	diversified_sampler: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-diversified-sampler-aggregation.html',
	filter: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-filter-aggregation.html',
	filters: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-filters-aggregation.html',
	geo_distance: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-geodistance-aggregation.html',
	geohash_grid: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-geohashgrid-aggregation.html',
	global: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-global-aggregation.html',
	histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-histogram-aggregation.html',
	ip_range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-iprange-aggregation.html',
	missing: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-missing-aggregation.html',
	nested: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-nested-aggregation.html',
	range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-range-aggregation.html',
	rare_terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-rare-terms-aggregation.html',
	reverse_nested: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-reverse-nested-aggregation.html',
	sampler: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-sampler-aggregation.html',
	significant_terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-significantterms-aggregation.html',
	significant_text: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-significanttext-aggregation.html',
	terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-terms-aggregation.html',
};

export const defaultValues = {
	adjancency_matrix: {
		separator: '@' // ES default
	},
	auto_date_histogram: {
		buckets: 10, // ES default
		format: 'YYYYMMdd', // Dapsboard default
		time_zone: 'UTC', // ES default
	},
	cardinality: {
		precision_threshold: 3000 // ES default
	},
	composite: {
		order: {
			_count: "desc", // ES default
		}
	},
	date_histogram: {
		min_doc_count: 1, // Dapsboard default
		order: {
			_count: "desc", // ES default
		},
		time_zone: 'UTC', // ES default
		__interval: {
			__type: 'interval', // Dapsboard internal
			interval: '1y', // Dapsboard default
			fixed_interval: '1y', // Dapsboard default
			calendar_interval: '1y', // Dapsboard default
		}
	},
	date_range: {
		format: 'YYYYMMdd', // Dapsboard default
		keyed: false, // ES default
	},
	diversified_sampler: {
		/*
		* ES default: The default setting is to use `global_ordinals` if this
		* information is available from the Lucene index and reverting to `map`
		* if not.
		*/
		execution_hint: 'global_ordinals',
		max_docs_per_value: 1, // ES default
		shard_size: 100, // ES default
	},
	extended_stats: {
		sigma: 2 // ES default
	},
	filters: {
		other_bucket: false, // not explicitly stated in the docs, must test
		other_bucket_key: '_other_' // ES default
	},
	geo_bounds: {
		wrap_longitude: true // ES default
	},
	geo_distance: {
		distance_type: 'arc', // ES default
		unit: 'm', // ES default
		keyed: false, // ES default
	},
	geohash_grid: {
		precision: 5, // ES default
		size: 10000, // ES default
		// shard_size: // ES default is -> max(10,(size x number-of-shards)) buckets from each shard.
	},
	histogram: {
		keyed: false, // ES default
		offset: 0, // ES default
		min_doc_count: 1, // Dapsboard default
		order: {
			_count: "desc" // ES default
		},
		// tentative template for handling computed defaults in the future
		// interval: (dataset, field, type) => // TODO compute default based on some stats request
	},
	median_absolute_deviation: {
		compression: 100, // ES default
	},
	percentiles: {
		keyed: true, // ES default
		percents: [1, 5, 25, 50, 75, 95, 99], // ES default
		tdigest: {
			compression: 100 // ES default
		}
	},
	percentile_ranks: {
		keyed: true // ES default
	},
	rare_terms: {
		precision: 0.01, // ES default
	},
	reverse_nested: {
		path: '' // ES default
	},
	sampler: {
		shard_size: 100 // ES default
	},
	significant_terms: {
		min_doc_count: 1, // Dapsboard default
	},
	significant_text: {
		filter_duplicate_text: false // ES default
	},
	terms: {
		// tentative template for handling computed defaults in the future
		// collect_mode: (dataset, field, type) => // TODO compute default based on cardinality request
		/*
		* Per ES below, `breadth_first` is the default mode for fields with a cardinality
		* bigger than the requested size or when the cardinality is unknown
		* (numeric fields or scripts for instance).
		*/
		collect_mode: 'depth_first',
		/*
		* Per ES below, `global_ordinals` is the default option for keyword field, it uses
		* global ordinals to allocate buckets dynamically so memory usage is linear to the
		* number of values of the documents that are part of the aggregation scope.
		*/
		execution_hint: 'global_ordinals',
		size: 10, // ES default
		order: {
			_count: "desc" // ES default
		},
	},
	top_hits: {
		size: 3, // ES default
		order: {
			_count: "desc" // ES default
		},
	},
	weighted_avg: {
		value: (dataset, field) => ({field}), // Dapsboard default
		weight: {
			script: '1' // Dapsboard default
		},
	}
}

const metricFieldParams = type => ({
	field: 'string',
	missing: [
		['integer', 'float'].includes(type)
			? type
			: 'string',
		'undefined'
	]
});

const sortOptions = {
	_key: ['"asc"', '"desc"', 'undefined'],
	_count: ['"asc"', '"desc"', 'undefined']
};

/*
// TODO replace?
const array = type => {
	if (typeof type === 'string') {
		return `${type}[]`;
	}
	return {
		__array: type
	};
}
*/

const paramsByMetricAgg = {
	avg: metricFieldParams,
	boxplot: type => ({
		...metricFieldParams(type),
		compresison: ['integer', 'undefined'],
	}),
	cardinality: type => ({
		...metricFieldParams(type),
		precision_threshold: ['integer', 'undefined'],
	}),
	extended_stats: type => ({
		...metricFieldParams(type),
		sigma: ['float', 'undefined'],
	}),
	geo_bounds: type => ({
		...metricFieldParams(type),
		wrap_longitude: ['boolean', 'undefined'],
	}),
	geo_centroid: metricFieldParams,
	max: metricFieldParams,
	median_absolute_deviation: type => ({
		...metricFieldParams(type),
		compresison: ['integer', 'undefined'],
	}),
	min: metricFieldParams,
	percentile_ranks: type => ({
		...metricFieldParams(type),
		values: 'float[]',
		keyed: ['boolean', 'undefined'],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	percentiles: type => ({
		...metricFieldParams(type),
		percents: ['float[]', 'undefined'],
		keyed: ['boolean', 'undefined'],
		tdigest: [
			{
				compression: 'integer'
			},
			'undefined'
		],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	scripted_metric: {
		init_script: 'Script',
		map_script: 'Script',
		combine_script: 'Script',
		reduce_script: 'Script',
	},
	stats: metricFieldParams,
	string_stats: type => ({
		...metricFieldParams(type),
		show_distribution: ['boolean', 'undefined']
	}),
	sum: metricFieldParams,
	t_test: type => ({
		a: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		b: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		type: ['"paired"', '"homoscedastic"', '"heteroscedastic"']
	}),
	top_hits: {
		from: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		sort: [sortOptions, 'undefined'],
		source: ['string', 'string[]']
	},
	top_metrics: type => ({
		metric: [
			metricFieldParams(type),
			{__array: metricFieldParams(type)}
		],
		sort: sortOptions,
		size: ['integer', 'undefined']
	}),
	value_count: metricFieldParams,
	weighted_avg: type => ({
		value: {
			...metricFieldParams(type)
		},
		weight: {
			...metricFieldParams(type)
		},
		format: ['json', 'undefined'],
		value_type: ['json', 'undefined']
	})
};

const paramsByBucketingAgg = {
	adjacency_matrix: {
		filters: {
			__record: 'string',
			__type: {
				__record: 'field',
				__type: 'string[]'
			}
		},
		separator: 'string'
	},
	auto_date_histogram: type => ({
		...metricFieldParams(type),
		buckets: ['integer', 'undefined'],
		format: ['string', 'undefined'],
		time_zone: ['string', 'undefined'],
		minimum_inteval: ['string', 'undefined'],
	}),
	children: {
		type: 'string'
	},
	composite: type => ({
		sources: {
			__record: 'string',
			__type: {
				...metricFieldParams(type),
				size: 'integer',
				order: [sortOptions, 'undefined']
			}
		},
		size: ['integer', 'undefined'],
		after: 'json'
	}),
	date_histogram: type => ({
		...metricFieldParams(type),
		__interval: {
			__type: ['"interval"', '"calendar_interval"', '"fixed_interval"'],
			interval: {
				__legacyName: 'DateInterval',
				__dateInterval: ''
			},
			calendar_interval: {
				__legacyName: 'CalendarInterval',
				__dateInterval: ''
			},
			fixed_interval: {
				__legacyName: 'FixedInterval',
				__dateInterval: ''
			}
		},
		time_zone: 'string',
		order: [sortOptions, 'undefined'],
		min_doc_count: ['integer', 'undefined']
	}),
	date_range: type => ({
		...metricFieldParams(type),
		format: 'string',
		ranges: {
			__array: {
				key: ['string', 'undefined'],
				from: ['string', 'undefined'],
				to: ['string', 'undefined']
			}
		},
		keyed: ['boolean', 'undefined']
	}),
	diversified_sampler: type => ({
		...metricFieldParams(type),
		execution_hint: [
			'"map"',
			'"global_ordinals"',
			'"bytes_hash"',
			'undefined'
		],
		max_docs_per_value: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	}),
	filter: {
		filter: 'json'
	},
	filters: {
		other_bucket: ['boolean', 'undefined'],
		other_bucket_key: ['string', 'undefined'],
		filters: {__array: 'json'},
	},
	geo_distance: type => ({
		...metricFieldParams(type),
		origin: 'string',
		unit: ['"m"', '"mi"', '"in"', '"yd"', '"km"', '"cm"', '"mm"'],
		ranges: {__array: 'json'},
		keyed: ['boolean', 'undefined'],
		distance_type: ['"arc"', '"plane"']
	}),
	geohash_grid: {
		field: 'field',
		precision: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	},
	global: {},
	histogram: type => ({
		...metricFieldParams(type),
		interval: type,
		offset: [type, 'undefined'],
		min_doc_count: ['integer', 'undefined'],
		keyed: ['boolean', 'undefined'],
		order: [sortOptions, 'undefined'],
		extended_bounds: [
			{
				__legacyName: `MinMax<${type}>`,
				min: type,
				max: type
			},
			'undefined'
		]
	}),
	ip_ranges: type => ({
		...metricFieldParams(type)
	}),
	missing: metricFieldParams,
	nested: {
		path: 'string'
	},
	range: {
		ranges: {__array: 'json'}
	},
	rare_terms: type => ({
		...metricFieldParams(type),
		max_doc_count: ['integer', 'undefined'],
		precision: ['float', 'undefined'],
		include: ['string[]', 'undefined'],
		exclude: ['string[]', 'undefined'],
	}),
	reverse_nested: {
		path: ['string', 'undefined']
	},
	sampler: {
		shard_size: ['integer', 'undefined']
	},
	significant_terms: type => ({
		...metricFieldParams(type),
		min_doc_count: ['integer', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		jlh: ['Existence', 'undefined'],
		mutual_information: [
			{
				include_negatives: ['boolean', 'undefined'],
				background_is_superset: ['boolean', 'undefined']
			}
		],
		chi_square: ['Existence', 'undefined'],
		gnd: ['Existence', 'undefined'],
		percentage: ['Existence', 'undefined'],
	}),
	significant_text: type => ({
		...metricFieldParams(type),
		filter_duplicate_text: ['boolean', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		source_fields: [
			{__array: 'string'},
			'undefined'
		]
	}),
	terms: type => ({
		...metricFieldParams(type),
		size: 'integer',
		collect_mode: [
			'"depth_first"',
			'"breadth_first"'
		],
		execution_hint: [
			'"global_ordinals"',
			'"map"'
		],
		order: [
			sortOptions,
			'undefined'
		]
	})
};

/*
const paramsByMatrixAgg = {
	matrix_stats: {
		fields: {__array: 'fields'},
		missing: [

			,
			'undefined'
		]
	}
};
*/

export const paramsByAggs = {
	...paramsByMetricAgg,
	...paramsByBucketingAgg,
	// ...paramsByMatrixAgg
}

const metricFieldDocs = {
	missing: 'A value to use if the field is missing entirely',
};

export const docsByParamByAgg = {
	avg: {
		__docs: 'Computes the average of numeric values that are extracted from the aggregated documents.',
		...metricFieldDocs,
	},
	boxplot: {
		__docs: 'Computes boxplot of numeric values extracted from the aggregated documents. ',
		...metricFieldDocs,
		compression: 'Approximate algorithms must balance memory utilization with estimation accuracy. This balance can be controlled using a compression parameter.',
	},
	cardinality: {
		__docs: 'Calculates an approximate count of distinct values.',
		...metricFieldDocs,
		precision_threshold: 'Allows to trade memory for accuracy, and defines a unique count below which counts are expected to be close to accurate. Above this value, counts might become a bit more fuzzy. The maximum supported value is 40000, thresholds above this number will have the same effect as a threshold of 40000. The default value is 3000.'
	},
	extended_stats: {
		__docs: 'Calculates an approximate count of distinct values.',
		...metricFieldDocs,
		sigma: 'sigma can be any non-negative double which controls how many standard deviations +/- from the mean should be displayed.'
	},
	geo_bounds: {
		__docs: 'Computes the bounding box containing all geo values for a field.',
		...metricFieldDocs,
		wrap_longitude: 'Specifies whether the bounding box should be allowed to overlap the international date line.'
	},
	geo_centroid: {
		__docs: 'Computes the weighted centroid from all coordinate values for geo fields.',
		...metricFieldDocs
	},
	max: {
		__docs: 'Returns the maximum value among the numeric values extracted from the aggregated documents.',
		...metricFieldDocs
	},
	median_absolute_deviation: {
		__docs: ' Median absolute deviation is a measure of variability. It is a robust statistic, meaning that it is useful for describing data that may have outliers, or may not be normally distributed. For such data it can be more descriptive than standard deviation.',
		...metricFieldDocs,
		compresison: 'The tradeoff between resource usage and accuracy of a TDigest’s quantile approximation, and therefore the accuracy of this aggregation’s approximation of median absolute deviation, is controlled by the compression parameter.'
	},
	min: {
		__docs: 'Returns the minimum value among numeric values extracted from the aggregated documents.',
		...metricFieldDocs
	},
	percentile_ranks: {
		__docs: 'Calculates one or more percentile ranks over numeric values extracted from the aggregated documents.',
		...metricFieldDocs,
		values: 'List of treshold values to use for ranking.',
		keyed: 'By default, the buckets are returned as an ordered array. It is also possible to request the response as a hash instead keyed by the buckets keys.',
		hdr: '(High Dynamic Range Histogram) is an alternative implementation that can be useful when calculating percentile ranks for latency measurements as it can be faster than the t-digest implementation with the trade-off of a larger memory footprint.'
	},
	percentiles: {
		__docs: 'Calculates one or more percentiles over numeric values extracted from the aggregated documents. ',
		...metricFieldDocs,
		percents: 'List of treshold values to use for ranking.',
		keyed: 'Setting the keyed flag to true will associate a unique string  key with each bucket and return the ranges as a hash rather than  an array.',
		tdigest: 'Format: {compression: integer}: The compression parameter limits the maximum number of nodes to 20 * compression.',
		hdr: 'hdr object indicates that HDR Histogram should be used to calculate  the percentiles and specific settings for this algorithm can be specified inside the object. Format:  {number_of_significant_value_digits: integer}'
	},
	scripted_metric: {
		__docs: 'A metric aggregation that executes using scripts to provide a metric output.',
		init_script: 'TODO',
		map_script: 'TODO',
		combine_script: 'TODO',
		reduce_script: 'TODO'
	},
	stats: {
		__docs: 'Computes stats over numeric values extracted from the aggregated documents.',
		...metricFieldDocs
	},
	string_stats: {
		__docs: 'Computes statistics over string values extracted from the aggregated documents',
		...metricFieldDocs,
		show_distribution: 'TODO',
	},
	sum: {
		__docs: 'Sums up numeric values that are extracted from the aggregated documents.',
		...metricFieldDocs,
	},
	t_test: {
		__docs: 'Performs a statistical hypothesis test in which the test statistic follows a Student’s t-distribution under the null hypothesis on numeric  values.',
		a: 'First field of numeric type.',
		b: 'Second field of numeric type.',
		type: 'The type of the test can be specified using the type parameter.'
	},
	top_hits: {
		__docs: 'Keeps track of the most relevant document being aggregated. This aggregator is intended to be used as a sub aggregator, so that the top matching documents can be aggregated per bucket.',
		from: 'The offset from the first result you want to fetch.',
		size: 'The maximum number of top matching hits to return per bucket. By default the top three matching hits are returned.',
		sort: 'How the top matching hits should be sorted. By default the hits are sorted by the score of the main query.',
		_source: 'Field names'
	},
	top_metrics: {
		__docs: 'Selects metrics from the document with the largest or smallest "sort" value.',
		metric: 'Selects the fields of the "top" document to return. You can request a single metric with something like "metric": {"field": "m"} or multiple metrics by requesting a list of metrics like "metric":  [{"field": "m"}, {"field": "i"}.',
		sort: 'Allows you to add one or more sorts on specific fields. Each sort can be reversed as well. The sort is defined on a per field level, with special field name for _score to sort by score, and _doc to sort by index order.',
		size: 'The maximum number of top matching hits to return per bucket. By default the top three matching hits are returned.'
	},
	value_count: {
		__docs: 'Counts the number of values that are extracted from the aggregated documents.',
		...metricFieldDocs
	},
	weighted_avg: {
		__docs: 'Computes the weighted average of numeric values that are extracted from the aggregated documents.',
		value: 'The configuration for the field or script that provides the values',
		weight: 'The configuration for the field or script that provides the weights',
		format: 'The numeric response formatter.',
		value_type: 'A hint about the values for pure scripts or unmapped fields.'
	},
	adjacency_matrix: {
		__docs: '',
	},
	auto_date_histogram: {
		__docs: '',
	},
	children: {
		__docs: '',
	},
	composite: {
		__docs: '',
	},
	date_histogram: {
		__docs: '',
	},
	date_range: {
		__docs: '',
	},
	diversified_sampler: {
		__docs: '',
	},
	filter: {
		__docs: '',
	},
	filters: {
		__docs: '',
	},
	geo_distance: {
		__docs: '',
	},
	geohash_grid: {
		__docs: '',
	},
	global: {
		__docs: '',
	},
	histogram: {
		__docs: '',
	},
	ip_ranges: {
		__docs: '',
	},
	missing: {
		__docs: '',
	},
	nested: {
		__docs: '',
	},
	range: {
		__docs: '',
	},
	rare_terms: {
		__docs: '',
	},
	reverse_nested: {
		__docs: '',
	},
	sampler: {
		__docs: '',
	},
	significant_terms: {
		__docs: '',
	},
	significant_text: {
		__docs: '',
	},
	terms: {
		__docs: '',
	}
}
