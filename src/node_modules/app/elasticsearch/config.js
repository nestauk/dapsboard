export const metricLabels = {
	// boxplot: 'BoxPlot',
	// matrix_stats: 'Matrix Stats',
	// median_absolute_deviation: 'Median Absolute Deviation' // >= 6.6
	// scripted_metric: 'Scripted Metric',
	// string_stats: 'String Statistics',
	// string_stats: 'String Stats' // >= 7.6
	avg: 'Average',
	cardinality: 'Cardinality',
	extended_stats: 'Extended Statistics',
	geo_bounds: 'Geographic Bounds',
	geo_centroid: 'Geographic Centroid',
	max: 'Maximum',
	median_absolute_deviation: 'Median Abs. Dev.',
	min: 'Minimum',
	percentile_ranks: 'Percentile Ranks',
	percentiles: 'Percentiles',
	stats: 'Statistics',
	sum: 'Sum',
	top_hits: 'Top Hits',
	value_count: 'Value Count'
}

export const metricMultiFieldLabels = {
	weighted_avg: 'Weighted Average'
}

export const topBucketLabels = {
	global: 'Global'
}

export const bucketLabels = {
	// auto_date_histogram: 'Auto Date Histogram' // >= 6.5
	// children: 'Children',
	auto_date_histogram: 'Auto Date Histogram',
	date_histogram: 'Date Histogram',
	date_range: 'Date Range',
	geo_distance: 'Geo Distance',
	geohash_grid: 'Geo Hash',
	histogram: 'Histogram',
	ip_ranges: 'IP Ranges',
	missing: 'Missing',
	nested: 'Nested',
	range: 'Range',
	rare_terms: 'Rare Terms',
	sampler: 'Sampler',
	significant_terms: 'Significant Terms',
	significant_text: 'Significant Text',
	terms: 'Terms',
}

export const bucketMultiFieldLabels = {
	composite: 'Composite',
	filter: 'Filter',
	filters: 'Filters',
}

export const nestedBucketLabels = {
	diversified_sampler: 'Diversified Sampler',
	reverse_nested: 'Reverse Nested',
}

export const aggsByType = {
	boolean: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'missing',
		'nested',
		'reverse_nested',
		'sampler',
		'value_count',
		// 'percentiles',
		// 'percentile_ranks',
	],
	date: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash_time: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash_T_time: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	ES_geo_point_obj: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'geo_bounds',
		'geo_centroid',
		'geo_distance',
		'geohash_grid',
		'missing',
		'nested',
		'reverse_nested',
		'sampler',
		'value_count',
	],
	ES_keyword: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	'ES_keyword[]': [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	ES_text_w_keyword: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	'ES_text_w_keyword[]': [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'reverse_nested',
		'rare_terms',
		'sampler',
		'significant_terms',
		'significant_text',
		'text',
		'terms',
		'value_count',
	],
	float: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'histogram',
		'max',
		'matrix_stats',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'percentiles',
		'percentile_ranks',
		'reverse_nested',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	integer: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'histogram',
		'max',
		'matrix_stats',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'percentiles',
		'percentile_ranks',
		'reverse_nested',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	object: []
}

export const AGG_DOC_URLS = {
	avg: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-avg-aggregation.html',
	cardinality: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-cardinality-aggregation.html',
	extended_stats: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-extendedstats-aggregation.html',
	geo_bounds: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-geobounds-aggregation.html',
	geo_centroid: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-geocentroid-aggregation.html',
	max: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-max-aggregation.html',
	median_absolute_deviation: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-median-absolute-deviation-aggregation.html',
	min: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-min-aggregation.html',
	percentiles: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-percentile-aggregation.html',
	percentile_ranks: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-percentile-rank-aggregation.html',
	scripted_metric: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-scripted-metric-aggregation.html',
	stats: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-stats-aggregation.html',
	sum: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-sum-aggregation.html',
	top_hits: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-top-hits-aggregation.html',
	value_count: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-valuecount-aggregation.html',
	weighted_avg: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-weight-avg-aggregation.html',

	adjacency_matrix: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-adjacency-matrix-aggregation.html',
	auto_date_histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-autodatehistogram-aggregation.html',
	children: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-children-aggregation.html',
	composite: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-composite-aggregation.html',
	date_histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-datehistogram-aggregation.html',
	date_range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-daterange-aggregation.html',
	diversified_sampler: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-diversified-sampler-aggregation.html',
	filter: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-filter-aggregation.html',
	filters: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-filters-aggregation.html',
	geo_distance: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-geodistance-aggregation.html',
	geohash_grid: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-geohashgrid-aggregation.html',
	global: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-global-aggregation.html',
	histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-histogram-aggregation.html',
	ip_range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-iprange-aggregation.html',
	missing: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-missing-aggregation.html',
	nested: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-nested-aggregation.html',
	range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-range-aggregation.html',
	rare_terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-rare-terms-aggregation.html',
	reverse_nested: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-reverse-nested-aggregation.html',
	sampler: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-sampler-aggregation.html',
	significant_terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-significantterms-aggregation.html',
	significant_text: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-significanttext-aggregation.html',
	terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-terms-aggregation.html',
};

export const defaultValues = {
	adjancency_matrix: {
		separator: '@' // ES default
	},
	auto_date_histogram: {
		buckets: 10, // ES default
		format: 'YYYYMMdd', // Dapsboard default
		time_zone: 'UTC', // ES default
	},
	cardinality: {
		precision_threshold: 3000 // ES default
	},
	composite: {
		order: {
			_count: "desc", // ES default
		}
	},
	date_histogram: {
		min_doc_count: 1, // Dapsboard default
		order: {
			_count: "desc", // ES default
		},
		time_zone: 'UTC', // ES default
		__interval: {
			__type: 'interval', // Dapsboard internal
			interval: '1y', // Dapsboard default
			fixed_interval: '1y', // Dapsboard default
			calendar_interval: '1y', // Dapsboard default
		}
	},
	date_range: {
		format: 'YYYYMMdd', // Dapsboard default
		keyed: false, // ES default
	},
	diversified_sampler: {
		/*
		* ES default: The default setting is to use `global_ordinals` if this
		* information is available from the Lucene index and reverting to `map`
		* if not.
		*/
		execution_hint: 'global_ordinals',
		max_docs_per_value: 1, // ES default
		shard_size: 100, // ES default
	},
	extended_stats: {
		sigma: 2 // ES default
	},
	filters: {
		other_bucket: false, // not explicitly stated in the docs, must test
		other_bucket_key: '_other_' // ES default
	},
	geo_bounds: {
		wrap_longitude: true // ES default
	},
	geo_distance: {
		distance_type: 'arc', // ES default
		unit: 'm', // ES default
		keyed: false, // ES default
	},
	geohash_grid: {
		precision: 5, // ES default
		size: 10000, // ES default
		// shard_size: // ES default is -> max(10,(size x number-of-shards)) buckets from each shard.
	},
	histogram: {
		keyed: false, // ES default
		offset: 0, // ES default
		min_doc_count: 1, // Dapsboard default
		order: {
			_count: "desc" // ES default
		},
		// tentative template for handling computed defaults in the future
		// interval: (dataset, field, type) => // TODO compute default based on some stats request
	},
	median_absolute_deviation: {
		compression: 100, // ES default
	},
	percentiles: {
		keyed: true, // ES default
		percents: [1, 5, 25, 50, 75, 95, 99], // ES default
		tdigest: {
			compression: 100 // ES default
		}
	},
	percentile_ranks: {
		keyed: true // ES default
	},
	rare_terms: {
		precision: 0.01, // ES default
	},
	reverse_nested: {
		path: '' // ES default
	},
	sampler: {
		shard_size: 100 // ES default
	},
	significant_terms: {
		min_doc_count: 1, // Dapsboard default
	},
	significant_text: {
		filter_duplicate_text: false // ES default
	},
	terms: {
		// tentative template for handling computed defaults in the future
		// collect_mode: (dataset, field, type) => // TODO compute default based on cardinality request
		/*
		* Per ES below, `breadth_first` is the default mode for fields with a cardinality
		* bigger than the requested size or when the cardinality is unknown
		* (numeric fields or scripts for instance).
		*/
		collect_mode: 'depth_first',
		/*
		* Per ES below, `global_ordinals` is the default option for keyword field, it uses
		* global ordinals to allocate buckets dynamically so memory usage is linear to the
		* number of values of the documents that are part of the aggregation scope.
		*/
		execution_hint: 'global_ordinals',
		size: 10, // ES default
		order: {
			_count: "desc" // ES default
		},
	},
	top_hits: {
		size: 3, // ES default
		order: {
			_count: "desc" // ES default
		},
	},
	weighted_avg: {
		value: (dataset, field) => ({field}), // Dapsboard default
		weight: {
			script: '1' // Dapsboard default
		},
	}
}

const metricFieldParams = type => ({
	field: 'field',
	missing: [type, 'undefined']
});

const sortOptions = {
	_key: ['"asc"', '"desc"', 'undefined'],
	_count: ['"asc"', '"desc"', 'undefined']
};

/*
// TODO replace?
const array = type => {
	if (typeof type === 'string') {
		return `${type}[]`;
	}
	return {
		__array: type
	};
}
*/

const paramsByMetricAgg = {
	avg: metricFieldParams,
	boxplot: type => ({
		...metricFieldParams(type),
		compresison: ['integer', 'undefined'],
	}),
	cardinality: type => ({
		...metricFieldParams(type),
		precision_threshold: ['integer', 'undefined'],
	}),
	extended_stats: type => ({
		...metricFieldParams(type),
		precision_threshold: ['float', 'undefined'],
	}),
	geo_bounds: type => ({
		...metricFieldParams(type),
		wrap_longitude: ['boolean', 'undefined'],
	}),
	geo_centroid: metricFieldParams,
	max: metricFieldParams,
	median_absolute_deviation: type => ({
		...metricFieldParams(type),
		compresison: ['integer', 'undefined'],
	}),
	min: metricFieldParams,
	percentile_ranks: type => ({
		...metricFieldParams(type),
		values: 'float[]',
		keyed: ['boolean', 'undefined'],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	percentiles: type => ({
		...metricFieldParams(type),
		percents: ['float[]', 'undefined'],
		keyed: ['boolean', 'undefined'],
		tdigest: [
			{
				compression: 'integer'
			},
			'undefined'
		],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	scripted_metric: {
		init_script: 'Script',
		map_script: 'Script',
		combine_script: 'Script',
		reduce_script: 'Script',
	},
	stats: metricFieldParams,
	string_stats: type => ({
		...metricFieldParams(type),
		show_distribution: ['boolean', 'undefined']
	}),
	sum: metricFieldParams,
	t_test: type => ({
		a: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		b: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		type: ['"paired"', '"homoscedastic"', '"heteroscedastic"']
	}),
	top_hits: {
		from: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		sort: [sortOptions, 'undefined'],
		source: ['string', 'string[]']
	},
	top_metrics: type => ({
		metric: [
			...metricFieldParams(type),
			{__array: metricFieldParams(type)}
		],
		sort: sortOptions,
		size: ['integer', 'undefined']
	}),
	value_count: metricFieldParams,
	weighted_avg: type => ({
		value: {
			...metricFieldParams(type)
		},
		weight: {
			...metricFieldParams(type)
		},
		format: ['json', 'undefined'],
		value_type: ['json', 'undefined']
	})
};

const paramsByBucketingAgg = {
	adjacency_matrix: {
		filters: {
			__record: 'string',
			__type: {
				__record: 'field',
				__type: 'string[]'
			}
		},
		separator: 'string'
	},
	auto_date_histogram: type => ({
		...metricFieldParams(type),
		buckets: ['integer', 'undefined'],
		format: ['string', 'undefined'],
		time_zone: ['string', 'undefined'],
		minimum_inteval: ['string', 'undefined'],
	}),
	children: {
		type: 'string'
	},
	composite: type => ({
		sources: {
			__record: 'string',
			__type: {
				...metricFieldParams(type),
				size: 'integer',
				order: [sortOptions, 'undefined']
			}
		},
		size: ['integer', 'undefined'],
		after: 'json'
	}),
	date_histogram: type => ({
		...metricFieldParams(type),
		__interval: {
			__type: ['"internal"', '"calendar_interval"', '"fixed_interval"'],
			interval: {
				__legacyName: 'DateInterval',
				__dateInterval: ''
			},
			calendar_interval: {
				__legacyName: 'CalendarInterval',
				__dateInterval: ''
			},
			fixed_interval: {
				__legacyName: 'FixedInterval',
				__dateInterval: ''
			}
		},
		time_zone: 'string',
		order: [sortOptions, 'undefined'],
		min_doc_count: ['integer', 'undefined']
	}),
	date_range: type => ({
		...metricFieldParams(type),
		format: 'string',
		ranges: {
			__array: {
				key: ['string', 'undefined'],
				from: ['string', 'undefined'],
				to: ['string', 'undefined']
			}
		},
		keyed: ['boolean', 'undefined']
	}),
	diversified_sampler: type => ({
		...metricFieldParams(type),
		execution_hint: [
			'"map"',
			'"global_ordinals"',
			'"bytes_hash"',
			'undefined'
		],
		max_docs_per_value: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	}),
	filter: {
		filter: 'json'
	},
	filters: {
		other_bucket: ['boolean', 'undefined'],
		other_bucket_key: ['string', 'undefined'],
		filters: {__array: 'json'},
	},
	geo_distance: type => ({
		...metricFieldParams(type),
		origin: 'string',
		unit: ['"m"', '"mi"', '"in"', '"yd"', '"km"', '"cm"', '"mm"'],
		ranges: {__array: 'json'},
		keyed: ['boolean', 'undefined'],
		distance_type: ['"arc"', '"plane"']
	}),
	geohash_grid: {
		field: 'field',
		precision: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	},
	global: {},
	histogram: type => ({
		...metricFieldParams(type),
		interval: type,
		offest: [type, 'undefined'],
		min_doc_count: ['integer', 'undefined'],
		keyed: ['boolean', 'undefined'],
		order: [sortOptions, 'undefined'],
		extended_bounds: [
			{
				__legacyName: `MinMax<${type}>`,
				min: type,
				max: type
			},
			'undefined'
		]
	}),
	ip_ranges: type => ({
		...metricFieldParams(type)
	}),
	missing: metricFieldParams,
	nested: {
		path: 'string'
	},
	range: {
		ranges: {__array: 'json'}
	},
	rare_terms: type => ({
		...metricFieldParams(type),
		max_doc_count: ['integer', 'undefined'],
		precision: ['float', 'undefined'],
		include: ['string[]', 'undefined'],
		exclude: ['string[]', 'undefined'],
	}),
	reverse_nested: {
		path: ['string', 'undefined']
	},
	sampler: {
		shard_size: ['integer', 'undefined']
	},
	significant_terms: type => ({
		...metricFieldParams(type),
		min_doc_count: ['integer', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		jlh: ['Existence', 'undefined'],
		mutual_information: [
			{
				include_negatives: ['boolean', 'undefined'],
				background_is_superset: ['boolean', 'undefined']
			}
		],
		chi_square: ['Existence', 'undefined'],
		gnd: ['Existence', 'undefined'],
		percentage: ['Existence', 'undefined'],
	}),
	significant_text: type => ({
		...metricFieldParams(type),
		filter_duplicate_text: ['boolean', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		source_fields: [
			{__array: 'string'},
			'undefined'
		]
	}),
	terms: type => ({
		...metricFieldParams(type),
		size: 'integer',
		collect_mode: [
			'"depth_first"',
			'"breadth_first"'
		],
		execution_hint: [
			'"global_ordinals"',
			'"map"'
		],
		order: [
			sortOptions,
			'undefined'
		]
	})
};

/*
const paramsByMatrixAgg = {
	matrix_stats: {
		fields: {__array: 'fields'},
		missing: [

			,
			'undefined'
		]
	}
};
*/

export const paramsByAggs = {
	...paramsByMetricAgg,
	...paramsByBucketingAgg,
	// ...paramsByMatrixAgg
}
