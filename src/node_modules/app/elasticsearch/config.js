export const metricLabels = {
	// boxplot: 'BoxPlot',
	// matrix_stats: 'Matrix Stats',
	// median_absolute_deviation: 'Median Absolute Deviation' // >= 6.6
	// scripted_metric: 'Scripted Metric',
	// string_stats: 'String Statistics',
	// string_stats: 'String Stats' // >= 7.6
	avg: 'Average',
	cardinality: 'Cardinality',
	extended_stats: 'Extended Statistics',
	geo_bounds: 'Geographic Bounds',
	geo_centroid: 'Geographic Centroid',
	max: 'Maximum',
	median_absolute_deviation: 'Median Abs. Dev.',
	min: 'Minimum',
	percentile_ranks: 'Percentile Ranks',
	percentiles: 'Percentiles',
	stats: 'Statistics',
	sum: 'Sum',
	top_hits: 'Top Hits',
	value_count: 'Value Count'
}

export const metricMultiFieldLabels = {
	weighted_avg: 'Weighted Average'
}

export const topBucketLabels = {
	global: 'Global'
}

export const bucketLabels = {
	// auto_date_histogram: 'Auto Date Histogram' // >= 6.5
	// children: 'Children',
	auto_date_histogram: 'Auto Date Histogram',
	date_histogram: 'Date Histogram',
	date_range: 'Date Range',
	geo_distance: 'Geo Distance',
	geohash_grid: 'Geo Hash',
	histogram: 'Histogram',
	ip_ranges: 'IP Ranges',
	missing: 'Missing',
	nested: 'Nested',
	range: 'Range',
	rare_terms: 'Rare Terms',
	sampler: 'Sampler',
	significant_terms: 'Significant Terms',
	significant_text: 'Significant Text',
	terms: 'Terms',
}

export const bucketMultiFieldLabels = {
	composite: 'Composite',
	filter: 'Filter',
	filters: 'Filters',
}

export const nestedBucketLabels = {
	diversified_sampler: 'Diversified Sampler',
	reverse_nested: 'Reverse Nested',
}

export const aggsByType = {
	boolean: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'missing',
		'nested',
		'reverse_nested',
		'sampler',
		'value_count',
		// 'percentiles',
		// 'percentile_ranks',
	],
	date: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash_time: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	Date_YYYYMMDD_dash_T_time: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'auto_date_histogram',
		'date_histogram',
		'date_range',
		'diversified_sampler',
		'extended_stats',
		'max',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'reverse_nested',
		'percentile_ranks',
		'percentiles',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	ES_geo_point_obj: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'geo_bounds',
		'geo_centroid',
		'geo_distance',
		'geohash_grid',
		'missing',
		'nested',
		'reverse_nested',
		'sampler',
		'value_count',
	],
	ES_keyword: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	'ES_keyword[]': [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	ES_text_w_keyword: [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'rare_terms',
		'reverse_nested',
		'sampler',
		'significant_terms',
		'significant_text',
		'terms',
		'value_count',
	],
	'ES_text_w_keyword[]': [
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'missing',
		'nested',
		'reverse_nested',
		'rare_terms',
		'sampler',
		'significant_terms',
		'significant_text',
		'text',
		'terms',
		'value_count',
	],
	float: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'histogram',
		'max',
		'matrix_stats',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'percentiles',
		'percentile_ranks',
		'reverse_nested',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	integer: [
		'avg',
		'cardinality',
		// 'children',
		'composite',
		'diversified_sampler',
		'extended_stats',
		'histogram',
		'max',
		'matrix_stats',
		'median_absolute_deviation',
		'min',
		'missing',
		'nested',
		'percentiles',
		'percentile_ranks',
		'reverse_nested',
		'sampler',
		'stats',
		'sum',
		'terms',
		'value_count',
		'weighted_avg',
	],
	object: []
}

export const AGG_DOC_URLS = {
	avg: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-avg-aggregation.html',
	boxplot: 'https://www.elastic.co/guide/en/elasticsearch/reference/master/search-aggregations-metrics-boxplot-aggregation.html',
	cardinality: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-cardinality-aggregation.html',
	extended_stats: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-extendedstats-aggregation.html',
	geo_bounds: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-geobounds-aggregation.html',
	geo_centroid: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-geocentroid-aggregation.html',
	max: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-max-aggregation.html',
	median_absolute_deviation: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-median-absolute-deviation-aggregation.html',
	min: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-min-aggregation.html',
	percentile_ranks: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-percentile-rank-aggregation.html',
	percentiles: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-percentile-aggregation.html',
	scripted_metric: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-scripted-metric-aggregation.html',
	stats: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-stats-aggregation.html',
	string_stats: 'https://www.elastic.co/guide/en/elasticsearch/reference/master/search-aggregations-metrics-string-stats-aggregation.html',
	sum: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-sum-aggregation.html',
	t_test: 'https://www.elastic.co/guide/en/elasticsearch/reference/master/search-aggregations-metrics-ttest-aggregation.html',
	top_hits: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-top-hits-aggregation.html',
	top_metrics: 'https://www.elastic.co/guide/en/elasticsearch/reference/master/search-aggregations-metrics-top-metrics.html',
	value_count: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-valuecount-aggregation.html',
	weighted_avg: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-metrics-weight-avg-aggregation.html',

	adjacency_matrix: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-adjacency-matrix-aggregation.html',
	auto_date_histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-autodatehistogram-aggregation.html',
	children: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-children-aggregation.html',
	composite: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-composite-aggregation.html',
	date_histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-datehistogram-aggregation.html',
	date_range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-daterange-aggregation.html',
	diversified_sampler: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-diversified-sampler-aggregation.html',
	filter: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-filter-aggregation.html',
	filters: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-filters-aggregation.html',
	geo_distance: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-geodistance-aggregation.html',
	geohash_grid: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-geohashgrid-aggregation.html',
	global: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-global-aggregation.html',
	histogram: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-histogram-aggregation.html',
	ip_range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-iprange-aggregation.html',
	missing: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-missing-aggregation.html',
	nested: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-nested-aggregation.html',
	range: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-range-aggregation.html',
	rare_terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-rare-terms-aggregation.html',
	reverse_nested: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-reverse-nested-aggregation.html',
	sampler: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-sampler-aggregation.html',
	significant_terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-significantterms-aggregation.html',
	significant_text: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-significanttext-aggregation.html',
	terms: 'https://www.elastic.co/guide/en/elasticsearch/reference/7.4/search-aggregations-bucket-terms-aggregation.html',
};

export const defaultValues = {
	adjancency_matrix: {
		separator: '@' // ES default
	},
	auto_date_histogram: {
		buckets: 10, // ES default
		format: 'YYYYMMdd', // Dapsboard default
		time_zone: 'UTC', // ES default
	},
	cardinality: {
		precision_threshold: 3000 // ES default
	},
	composite: {
		order: {
			_count: "desc", // ES default
		}
	},
	date_histogram: {
		min_doc_count: 1, // Dapsboard default
		order: {
			_count: "desc", // ES default
		},
		time_zone: 'UTC', // ES default
		__interval: {
			__type: 'interval', // Dapsboard internal
			interval: '1y', // Dapsboard default
			fixed_interval: '1y', // Dapsboard default
			calendar_interval: '1y', // Dapsboard default
		}
	},
	date_range: {
		format: 'YYYYMMdd', // Dapsboard default
		keyed: false, // ES default
	},
	diversified_sampler: {
		/*
		* ES default: The default setting is to use `global_ordinals` if this
		* information is available from the Lucene index and reverting to `map`
		* if not.
		*/
		execution_hint: 'global_ordinals',
		max_docs_per_value: 1, // ES default
		shard_size: 100, // ES default
	},
	extended_stats: {
		sigma: 2 // ES default
	},
	filters: {
		other_bucket: false, // not explicitly stated in the docs, must test
		other_bucket_key: '_other_' // ES default
	},
	geo_bounds: {
		wrap_longitude: true // ES default
	},
	geo_distance: {
		distance_type: 'arc', // ES default
		unit: 'm', // ES default
		keyed: false, // ES default
	},
	geohash_grid: {
		precision: 5, // ES default
		size: 10000, // ES default
		// shard_size: // ES default is -> max(10,(size x number-of-shards)) buckets from each shard.
	},
	histogram: {
		keyed: false, // ES default
		offset: 0, // ES default
		min_doc_count: 1, // Dapsboard default
		order: {
			_count: "desc" // ES default
		},
		// tentative template for handling computed defaults in the future
		// interval: (dataset, field, type) => // TODO compute default based on some stats request
	},
	median_absolute_deviation: {
		compression: 100, // ES default
	},
	percentile_ranks: {
		keyed: true // ES default
	},
	percentiles: {
		keyed: true, // ES default
		percents: [1, 5, 25, 50, 75, 95, 99], // ES default
		tdigest: {
			compression: 100 // ES default
		}
	},
	rare_terms: {
		precision: 0.01, // ES default
	},
	reverse_nested: {
		path: '' // ES default
	},
	sampler: {
		shard_size: 100 // ES default
	},
	significant_terms: {
		min_doc_count: 1, // Dapsboard default
	},
	significant_text: {
		filter_duplicate_text: false // ES default
	},
	terms: {
		// tentative template for handling computed defaults in the future
		// collect_mode: (dataset, field, type) => // TODO compute default based on cardinality request
		/*
		* Per ES below, `breadth_first` is the default mode for fields with a cardinality
		* bigger than the requested size or when the cardinality is unknown
		* (numeric fields or scripts for instance).
		*/
		collect_mode: 'depth_first',
		/*
		* Per ES below, `global_ordinals` is the default option for keyword field, it uses
		* global ordinals to allocate buckets dynamically so memory usage is linear to the
		* number of values of the documents that are part of the aggregation scope.
		*/
		execution_hint: 'global_ordinals',
		size: 10, // ES default
		order: {
			_count: "desc" // ES default
		},
	},
	top_hits: {
		size: 3, // ES default
		order: {
			_count: "desc" // ES default
		},
	},
	weighted_avg: {
		value: (dataset, field) => ({field}), // Dapsboard default
		weight: {
			script: '1' // Dapsboard default
		},
	}
}

const metricFieldParams = type => ({
	field: 'string',
	missing: [
		['integer', 'float'].includes(type)
			? type
			: 'string',
		'undefined'
	]
});

const sortOptions = {
	_key: ['"asc"', '"desc"', 'undefined'],
	_count: ['"asc"', '"desc"', 'undefined']
};

/*
// TODO replace?
const array = type => {
	if (typeof type === 'string') {
		return `${type}[]`;
	}
	return {
		__array: type
	};
}
*/

const paramsByMetricAgg = {
	avg: metricFieldParams,
	boxplot: type => ({
		...metricFieldParams(type),
		compression: ['integer', 'undefined'],
	}),
	cardinality: type => ({
		...metricFieldParams(type),
		precision_threshold: ['integer', 'undefined'],
	}),
	extended_stats: type => ({
		...metricFieldParams(type),
		sigma: ['float', 'undefined'],
	}),
	geo_bounds: type => ({
		...metricFieldParams(type),
		wrap_longitude: ['boolean', 'undefined'],
	}),
	geo_centroid: metricFieldParams,
	max: metricFieldParams,
	median_absolute_deviation: type => ({
		...metricFieldParams(type),
		compresison: ['integer', 'undefined'],
	}),
	min: metricFieldParams,
	percentile_ranks: type => ({
		...metricFieldParams(type),
		values: 'float[]',
		keyed: ['boolean', 'undefined'],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	percentiles: type => ({
		...metricFieldParams(type),
		percents: ['float[]', 'undefined'],
		keyed: ['boolean', 'undefined'],
		tdigest: [
			{
				compression: 'integer'
			},
			'undefined'
		],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	scripted_metric: {
		init_script: 'Script',
		map_script: 'Script',
		combine_script: 'Script',
		reduce_script: 'Script',
	},
	stats: metricFieldParams,
	string_stats: type => ({
		...metricFieldParams(type),
		show_distribution: ['boolean', 'undefined']
	}),
	sum: metricFieldParams,
	t_test: type => ({
		a: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		b: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		type: ['"paired"', '"homoscedastic"', '"heteroscedastic"']
	}),
	top_hits: {
		from: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		sort: [sortOptions, 'undefined'],
		_source: ['string', 'string[]']
	},
	top_metrics: type => ({
		metric: [
			metricFieldParams(type),
			{__array: metricFieldParams(type)}
		],
		sort: sortOptions,
		size: ['integer', 'undefined']
	}),
	value_count: metricFieldParams,
	weighted_avg: type => ({
		value: {
			...metricFieldParams(type)
		},
		weight: {
			...metricFieldParams(type)
		},
		format: ['json', 'undefined'],
		value_type: ['json', 'undefined']
	})
};

const paramsByBucketingAgg = {
	adjacency_matrix: {
		filters: {
			__record: 'string',
			__type: {
				__record: 'field',
				__type: 'string[]'
			}
		},
		separator: 'string'
	},
	auto_date_histogram: type => ({
		...metricFieldParams(type),
		buckets: ['integer', 'undefined'],
		format: ['string', 'undefined'],
		time_zone: ['string', 'undefined'],
		minimum_inteval: ['string', 'undefined'],
	}),
	children: {
		type: 'string'
	},
	composite: type => ({
		sources: {
			__record: 'string',
			__type: {
				...metricFieldParams(type),
				size: 'integer',
				order: [sortOptions, 'undefined']
			}
		},
		size: ['integer', 'undefined'],
		after: 'json'
	}),
	date_histogram: type => ({
		...metricFieldParams(type),
		__interval: {
			__type: ['"interval"', '"calendar_interval"', '"fixed_interval"'],
			interval: {
				__legacyName: 'DateInterval',
				__dateInterval: ''
			},
			calendar_interval: {
				__legacyName: 'CalendarInterval',
				__dateInterval: ''
			},
			fixed_interval: {
				__legacyName: 'FixedInterval',
				__dateInterval: ''
			}
		},
		time_zone: 'string',
		order: [sortOptions, 'undefined'],
		min_doc_count: ['integer', 'undefined']
	}),
	date_range: type => ({
		...metricFieldParams(type),
		format: 'string',
		ranges: {
			__array: {
				key: ['string', 'undefined'],
				from: ['string', 'undefined'],
				to: ['string', 'undefined']
			}
		},
		keyed: ['boolean', 'undefined']
	}),
	diversified_sampler: type => ({
		...metricFieldParams(type),
		execution_hint: [
			'"map"',
			'"global_ordinals"',
			'"bytes_hash"',
			'undefined'
		],
		max_docs_per_value: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	}),
	filter: {
		filter: 'json'
	},
	filters: {
		other_bucket: ['boolean', 'undefined'],
		other_bucket_key: ['string', 'undefined'],
		filters: {__array: 'json'},
	},
	geo_distance: type => ({
		...metricFieldParams(type),
		origin: 'string',
		unit: ['"m"', '"mi"', '"in"', '"yd"', '"km"', '"cm"', '"mm"'],
		ranges: {__array: 'json'},
		keyed: ['boolean', 'undefined'],
		distance_type: ['"arc"', '"plane"']
	}),
	geohash_grid: {
		field: 'field',
		precision: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	},
	global: {},
	histogram: type => ({
		...metricFieldParams(type),
		interval: type,
		offset: [type, 'undefined'],
		min_doc_count: ['integer', 'undefined'],
		keyed: ['boolean', 'undefined'],
		order: [sortOptions, 'undefined'],
		extended_bounds: [
			{
				__legacyName: `MinMax<${type}>`,
				min: type,
				max: type
			},
			'undefined'
		]
	}),
	ip_range: type => ({
		...metricFieldParams(type)
	}),
	missing: metricFieldParams,
	nested: {
		path: 'string'
	},
	range: type => ({
		...metricFieldParams(type),
		ranges: {__array: 'json'}
	}),
	rare_terms: type => ({
		...metricFieldParams(type),
		max_doc_count: ['integer', 'undefined'],
		precision: ['float', 'undefined'],
		include: ['string[]', 'undefined'],
		exclude: ['string[]', 'undefined'],
	}),
	reverse_nested: {
		path: ['string', 'undefined']
	},
	sampler: {
		shard_size: ['integer', 'undefined']
	},
	significant_terms: type => ({
		...metricFieldParams(type),
		min_doc_count: ['integer', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		jlh: ['Existence', 'undefined'],
		mutual_information: [
			{
				include_negatives: ['boolean', 'undefined'],
				background_is_superset: ['boolean', 'undefined']
			}
		],
		chi_square: ['Existence', 'undefined'],
		gnd: ['Existence', 'undefined'],
		percentage: ['Existence', 'undefined'],
	}),
	significant_text: type => ({
		...metricFieldParams(type),
		filter_duplicate_text: ['boolean', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		source_fields: [
			{__array: 'string'},
			'undefined'
		]
	}),
	terms: type => ({
		...metricFieldParams(type),
		size: 'integer',
		collect_mode: [
			'"depth_first"',
			'"breadth_first"'
		],
		execution_hint: [
			'"global_ordinals"',
			'"map"'
		],
		order: [
			sortOptions,
			'undefined'
		]
	})
};

/*
const paramsByMatrixAgg = {
	matrix_stats: {
		fields: {__array: 'fields'},
		missing: [

			,
			'undefined'
		]
	}
};
*/

export const paramsByAggs = {
	...paramsByMetricAgg,
	...paramsByBucketingAgg,
	// ...paramsByMatrixAgg
}

const metricFieldDocs = {
	missing: 'A value to use if the field is missing entirely',
};

export const docsByParamByAgg = {
	avg: {
		__docs: 'Computes the average of numeric values that are extracted from the aggregated documents.',
		...metricFieldDocs,
	},
	boxplot: {
		__docs: 'Computes boxplot of numeric values extracted from the aggregated documents. ',
		...metricFieldDocs,
		compression: 'Approximate algorithms must balance memory utilization with estimation accuracy. This balance can be controlled using a compression parameter.',
	},
	cardinality: {
		__docs: 'Calculates an approximate count of distinct values.',
		...metricFieldDocs,
		precision_threshold: 'Allows to trade memory for accuracy, and defines a unique count below which counts are expected to be close to accurate. Above this value, counts might become a bit more fuzzy. The maximum supported value is 40000, thresholds above this number will have the same effect as a threshold of 40000. The default value is 3000.'
	},
	extended_stats: {
		__docs: 'Calculates an approximate count of distinct values.',
		...metricFieldDocs,
		sigma: 'sigma can be any non-negative double which controls how many standard deviations +/- from the mean should be displayed.'
	},
	geo_bounds: {
		__docs: 'Computes the bounding box containing all geo values for a field.',
		...metricFieldDocs,
		wrap_longitude: 'Specifies whether the bounding box should be allowed to overlap the international date line.'
	},
	geo_centroid: {
		__docs: 'Computes the weighted centroid from all coordinate values for geo fields.',
		...metricFieldDocs
	},
	max: {
		__docs: 'Returns the maximum value among the numeric values extracted from the aggregated documents.',
		...metricFieldDocs
	},
	median_absolute_deviation: {
		__docs: ' Median absolute deviation is a measure of variability. It is a robust statistic, meaning that it is useful for describing data that may have outliers, or may not be normally distributed. For such data it can be more descriptive than standard deviation.',
		...metricFieldDocs,
		compresison: 'The tradeoff between resource usage and accuracy of a TDigest’s quantile approximation, and therefore the accuracy of this aggregation’s approximation of median absolute deviation, is controlled by the compression parameter.'
	},
	min: {
		__docs: 'Returns the minimum value among numeric values extracted from the aggregated documents.',
		...metricFieldDocs
	},
	percentile_ranks: {
		__docs: 'Calculates one or more percentile ranks over numeric values extracted from the aggregated documents.',
		...metricFieldDocs,
		values: 'List of treshold values to use for ranking.',
		keyed: 'By default, the buckets are returned as an ordered array. It is also possible to request the response as a hash instead keyed by the buckets keys.',
		hdr: '(High Dynamic Range Histogram) is an alternative implementation that can be useful when calculating percentile ranks for latency measurements as it can be faster than the t-digest implementation with the trade-off of a larger memory footprint.'
	},
	percentiles: {
		__docs: 'Calculates one or more percentiles over numeric values extracted from the aggregated documents. ',
		...metricFieldDocs,
		percents: 'List of treshold values to use for ranking.',
		keyed: 'Setting the keyed flag to true will associate a unique string  key with each bucket and return the ranges as a hash rather than  an array.',
		tdigest: 'Format: {compression: integer}: The compression parameter limits the maximum number of nodes to 20 * compression.',
		hdr: 'hdr object indicates that HDR Histogram should be used to calculate  the percentiles and specific settings for this algorithm can be specified inside the object. Format:  {number_of_significant_value_digits: integer}'
	},
	scripted_metric: {
		__docs: 'A metric aggregation that executes using scripts to provide a metric output.',
		init_script: 'TODO',
		map_script: 'TODO',
		combine_script: 'TODO',
		reduce_script: 'TODO'
	},
	stats: {
		__docs: 'Computes stats over numeric values extracted from the aggregated documents.',
		...metricFieldDocs
	},
	string_stats: {
		__docs: 'Computes statistics over string values extracted from the aggregated documents',
		...metricFieldDocs,
		show_distribution: 'TODO',
	},
	sum: {
		__docs: 'Sums up numeric values that are extracted from the aggregated documents.',
		...metricFieldDocs,
	},
	t_test: {
		__docs: 'Performs a statistical hypothesis test in which the test statistic follows a Student’s t-distribution under the null hypothesis on numeric  values.',
		a: 'First field of numeric type.',
		b: 'Second field of numeric type.',
		type: 'The type of the test can be specified using the type parameter.'
	},
	top_hits: {
		__docs: 'Keeps track of the most relevant document being aggregated. This aggregator is intended to be used as a sub aggregator, so that the top matching documents can be aggregated per bucket.',
		from: 'The offset from the first result you want to fetch.',
		size: 'The maximum number of top matching hits to return per bucket. By default the top three matching hits are returned.',
		sort: 'How the top matching hits should be sorted. By default the hits are sorted by the score of the main query.',
		_source: 'Field names'
	},
	top_metrics: {
		__docs: 'Selects metrics from the document with the largest or smallest "sort" value.',
		metric: 'Selects the fields of the "top" document to return. You can request a single metric with something like "metric": {"field": "m"} or multiple metrics by requesting a list of metrics like "metric":  [{"field": "m"}, {"field": "i"}.',
		sort: 'Allows you to add one or more sorts on specific fields. Each sort can be reversed as well. The sort is defined on a per field level, with special field name for _score to sort by score, and _doc to sort by index order.',
		size: 'The maximum number of top matching hits to return per bucket. By default the top three matching hits are returned.'
	},
	value_count: {
		__docs: 'Counts the number of values that are extracted from the aggregated documents.',
		...metricFieldDocs
	},
	weighted_avg: {
		__docs: 'Computes the weighted average of numeric values that are extracted from the aggregated documents.',
		value: 'The configuration for the field or script that provides the values',
		weight: 'The configuration for the field or script that provides the weights',
		format: 'The numeric response formatter.',
		value_type: 'A hint about the values for pure scripts or unmapped fields.'
	},
	adjacency_matrix: {
		__docs: 'A bucket aggregation returning a form of adjacency matrix. The request provides a collection of named filter expressions, similar to the filters aggregation request.',
		filters: 'Named list of Elasticsearch filters: { name1: {...}, ...}',
		separator: 'Separator character used in response.'
	},
	auto_date_histogram: {
		__docs: 'A multi-bucket aggregation similar to the Date histogram aggregation except instead of providing an interval to use as the width of each bucket, a target number of buckets is provided indicating the number of buckets needed and the interval of the buckets is automatically chosen to best achieve that target. The number of buckets returned will always be less than or equal to this target number.',
		...metricFieldDocs,
		buckets: 'The buckets field is optional, and will default to 10 buckets if not specified.',
		format: 'Date format pattern specification.',
		time_zone: 'The time_zone parameter can be used to indicate that bucketing should use a different time zone.',
		minimum_inteval: 'The minimum_interval allows the caller to specify the minimum rounding interval that should be used. This can make the collection process more efficient, as the aggregation will not attempt to round at any interval lower than minimum_interval.'
	},
	children: {
		__docs: 'A special single bucket aggregation that selects child documents that have the specified type, as defined in a join field.',
		type: 'Points to type / mapping with the value as name'
	},
	composite: {
		__docs: 'A multi-bucket aggregation that creates composite buckets from different sources.',
		sources: 'The sources parameter controls the sources that should be used to build the composite buckets. The order that the sources are defined is important because it also controls the order the keys are returned.',
		size: 'The size parameter can be set to define how many composite buckets  should be returned. Used for pagination.',
		after: 'To get the next set of buckets, resend the same aggregation with the after parameter set to the after_key value returned in the response.  This request uses the after_key value provided in the previous response.'
	},
	date_histogram: {
		__docs: 'This multi-bucket aggregation is similar to the normal histogram, but it can only be used with date values. Because dates are represented internally in Elasticsearch as long values, it is possible, but not as accurate, to use the normal histogram on dates as well.',
		...metricFieldDocs,
		__interval: 'Select among `interval` for ES < 7 datasets and `calendar_interval` and `fixed_interval` for ES >= 7.',
		time_zone: 'Use the time_zone parameter to indicate that bucketing should use  a different time zone.',
		order: 'The order of the buckets can be customized by setting the order  parameter.',
		min_doc_count: 'It is possible to only return terms that match more than a  configured number of hits using the min_doc_count option.'
	},
	date_range: {
		__docs: 'A range aggregation that is dedicated for date values. The main difference between this aggregation and the normal range aggregation is that the from and to values can be expressed in Date Math expressions, and it is also possible to specify a date format by which the from and to response fields will be returned.',
		...metricFieldDocs,
		format: 'Date Format/Pattern',
		ranges: 'Array of objects of shape {from: string, to: string} where the strings represent dates.',
		keyed: 'Setting the keyed flag to true will associate a unique string  key with each bucket and return the ranges as a hash rather than  an array.'
	},
	diversified_sampler: {
		__docs: 'Like the sampler aggregation this is a filtering aggregation used to limit any sub aggregations processing to a sample of the top-scoring documents. The diversified_sampler aggregation adds the ability to limit the number of matches that share a common value such as an "author".',
		...metricFieldDocs,
		execution_hint: 'The optional execution_hint setting can influence the management of the values used for de-duplication. Each option will hold up to `shard_size` values in memory while performing de-duplication but the type of value held can be controlled as follows: * hold field values directly (`map`) * hold ordinals of the field as determined by the Lucene index (`global_ordinals`) * hold hashes of the field values - with potential for hash collisions (`bytes_hash`)',
		max_docs_per_value: 'The max_docs_per_value is an optional parameter and limits how many documents are permitted per choice of de-duplicating value. The default setting is "1".',
		shard_size: 'The shard_size parameter limits how many top-scoring documents are collected in the sample processed on each shard. The default value is 100.'
	},
	filter: {
		__docs: 'Defines a single bucket of all the documents in the current document set context that match a specified filter. Often this will be used to narrow down the current aggregation context to a specific set of documents.',
		filter: 'Elasticsearch filter object format.'
	},
	filters: {
		__docs: 'Defines a multi bucket aggregation where each bucket is associated with a filter. Each bucket will collect all documents that match its associated filter.',
		other_bucket: 'Can be set to add a bucket to the response which will contain all documents that do not match any of the given filters.',
		other_bucket_key: 'Can be used to set the key for the other bucket to a value other than the default _other_. Setting this parameter will implicitly set the other_bucket parameter to true.',
		filters: 'Named list of Elasticsearch filters: { name1: {...}, ...}'
	},
	geo_distance: {
		__docs: 'A multi-bucket aggregation that works on geo_point fields and conceptually works very similar to the range aggregation. The user can define a point of origin and a set of distance range buckets.',
		...metricFieldDocs,
		origin: 'The `origin` point can accept all formats supported by the  `geo_point` type.',
		unit: 'By default, the distance unit is m (meters) but it can also accept:  mi (miles), in (inches), yd (yards), km (kilometers), cm (centimeters), mm (millimeters).',
		ranges: 'Array of objects of shape {from: ..., to: ...}',
		keyed: 'By default, the buckets are returned as an ordered array. It is also possible to request the response as a hash instead keyed by the buckets keys.',
		distance_type: 'The distance calculation type can be set using the distance_type parameter.'
	},
	geohash_grid: {
		__docs: 'A multi-bucket aggregation that works on geo_point fields and groups points into buckets that represent cells in a grid. The resulting grid can be sparse and only contains cells that have matching data.',
		precision: 'The string length of the geohashes used to define cells/buckets in the results. Defaults to 5.',
		size: 'The maximum number of geohash buckets to return (defaults to 10,000).',
		shard_size: 'To allow for more accurate counting of the top cells returned in the final result the aggregation defaults to returning max(10,(size x number-of-shards)) buckets from each shard. If this heuristic is undesirable, the number considered from each shard can be over-ridden using this parameter.'
	},
	global: {
		__docs: 'Defines a single bucket of all the documents within the search execution context. This context is defined by the indices and the document types you’re searching on, but is not influenced by the search query itself.',
	},
	histogram: {
		__docs: 'A multi-bucket values source based aggregation that can be applied on numeric values extracted from the documents.',
		...metricFieldDocs,
		interval: 'When the aggregation executes, the selected field of every document  will be evaluated and will be rounded down to its closest bucket.  Must be a positive decimal.',
		offset: 'Shifts bucket boundaries. Must be a decimal greater than or equal to 0 and less than interval.',
		min_doc_count: 'By default the response will fill gaps in the histogram with empty buckets. It is possible change that and request buckets with a higher minimum count thanks to the min_doc_count setting.',
		keyed: 'By default, the buckets are returned as an ordered array. It is also possible to request the response as a hash instead keyed by the buckets keys.',
		order: 'The order of the buckets can be customized by setting the order  parameter. ',
		extended_bounds: 'With extended_bounds setting, you now can "force" the histogram  aggregation to start building buckets on a specific min value and  also keep on building buckets up to a max value (even if there are  no documents anymore). Using extended_bounds only makes sense when  min_doc_count is 0 (the empty buckets will never be returned if  min_doc_count is greater than 0).'
	},
	ip_range: {
		__docs: 'A dedicated range aggregation for IP typed fields.',
		...metricFieldDocs
	},
	missing: {
		__docs: 'A field data based single bucket aggregation, that creates a bucket of all documents in the current document set context that are missing a field value (effectively, missing a field or having the configured NULL value set).',
		...metricFieldDocs
	},
	nested: {
		__docs: 'A special single bucket aggregation that enables aggregating nested documents.',
		path: 'Path of the nested documents within the top level documents.',
	},
	range: {
		__docs: 'A multi-bucket value source based aggregation that enables the user to define a set of ranges - each representing a bucket.',
		...metricFieldDocs,
		ranges: '',
	},
	rare_terms: {
		__docs: 'Multi-bucket value source based aggregation which finds "rare" terms — terms that are at the long-tail of the distribution and are not frequent.',
		...metricFieldDocs,
		max_doc_count: 'The maximum number of documents a term should appear in.',
		precision: 'The precision of the internal CuckooFilters. Smaller precision  leads to better approximation, but higher memory usage.  Cannot be smaller than 0.00001. Default 0.01',
		include: 'Terms that should be included in the aggregation',
		exclude: 'Terms that should be excluded from the aggregation'
	},
	reverse_nested: {
		__docs: 'A special single bucket aggregation that enables aggregating on parent docs from nested documents. Effectively this aggregation can break out of the nested block structure and link to other nested structures or the root document, which allows nesting other aggregations that aren’t part of the nested object in a nested aggregation.',
		path: 'Path of the nested documents within the top level documents.'
	},
	sampler: {
		__docs: 'A filtering aggregation used to limit any sub aggregations processing to a sample of the top-scoring documents.',
		shard_size: 'The shard_size parameter limits how many top-scoring documents are collected in the sample processed on each shard. The default value is 100.'
	},
	significant_terms: {
		__docs: 'An aggregation that returns interesting or unusual occurrences of terms in a set.',
		...metricFieldDocs,
		min_doc_count: 'It is possible to only return terms that match more than a  configured number of hits using the min_doc_count option.',
		background_filter: 'The default source of statistical information for background term frequencies is the entire index and this scope can be narrowed through the use of a background_filter to focus in on significant terms within a narrower context.',
		jlh: 'The JLH score can be used as a significance score by adding `{}`.',
		mutual_information: 'Mutual information as described in "Information Retrieval", Manning et al., Chapter 13.5.1 can be used as significance score by adding `{}`',
		chi_square: 'Chi square as described in "Information Retrieval", Manning et al., Chapter 13.5.2 can be used as significance score by adding `{}`',
		gnd: 'Google normalized distance as described in "The Google Similarity Distance", Cilibrasi and Vitanyi, 2007 (http://arxiv.org/pdf/cs/0412098v3.pdf) can be used as significance score by adding `{}`',
		percentage: 'A simple calculation of the number of documents in the foreground sample with a term divided by the number of documents in the background with the term. By default this produces a score greater than zero and less than one.'
	},
	significant_text: {
		__docs: 'An aggregation that returns interesting or unusual occurrences of free-text terms in a set.',
		...metricFieldDocs,
		filter_duplicate_text: 'Filtering near-duplicate text is a difficult task at index-time but we can cleanse the data on-the-fly at query time using the `filter_duplicate_text` setting.',
		background_filter: 'The default source of statistical information for background term frequencies is the entire index and this scope can be narrowed through the use of a background_filter to focus in on significant terms within a narrower context.',
		source_fields: 'List of JSON _source fields from which text will be analyzed.'
	},
	terms: {
		__docs: 'A multi-bucket value source based aggregation where buckets are  dynamically built - one per unique value.',
		...metricFieldDocs,
		size: 'By default, the terms aggregation will return the buckets for the top ten terms ordered by the doc_count. One can change this default behaviour by setting the size parameter.',
		collect_mode: 'Deferring calculation of child aggregations.',
		execution_hint: 'Mechanisms by which terms aggregations can be executed.',
		order: 'The order of the buckets can be customized by setting the order  parameter. '
	}
}
