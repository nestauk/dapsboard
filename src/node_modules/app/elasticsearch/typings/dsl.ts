// Utility types

type ExactlyOneOfSome<T, K extends keyof T = keyof T> = K extends unknown
    ? { 
        [I in keyof T]?: I extends K
            ? T[I]
            : never;
    }
    : never;

type ExactlyOne<T> = ExactlyOneOfSome<T, keyof T>;

// ElasticSearch Typings
// ElasticSearch Helper Types

export type ScriptLanguage = 'painless' | 'expression' | 'mustache' | 'java';

export type SortOrder = 'asc' | 'desc';

export type SortInstruction<Dataset> = 
    Record<keyof Dataset, SortOrder | { order: SortOrder }>;

export type SortOptions<Dataset> = 
    SortOrder | 
    SortInstruction<Dataset> | 
    SortInstruction<Dataset>[];

export type SourceOptions<Dataset> = string | string[];  //TODO incomplete


//Aggregation Helper Types

// This is a rather 'abstract' base interface
export type ScriptBase = {
	lang?: ScriptLanguage;
	params?: Record<string, string | number>;
}

export type LiteralScript = ScriptBase | {
	source: string;
}

export type ScriptReference = ScriptBase | {
	id: string;
}

// These are the actual values accepted by ES.
// Note that ScriptBase is not icluded
export type Script = {
    script: string | LiteralScript | ScriptReference;
}

export type MetricField<Dataset, Key extends keyof Dataset = keyof Dataset> = 
    Key extends keyof Dataset
        ? {
            /**
             * The field that values should be extracted from
             */
            field: Key;

            /**
             * A value to use if the field is missing entirely
             */
            missing?: Dataset[Key];
        }
        : never;

export type MetricAggregationConfig<Dataset, Keys extends keyof Dataset> = 
    MetricField<Dataset, Keys> /* | Script */;
// TODO Investigate why using the `Script` type above makes completions fail

export type MetricAggregations<Dataset, Fields extends keyof Dataset> = {
    avg: MetricAggregationConfig<Dataset, Fields>;
    cardinality: MetricAggregationConfig<Dataset, Fields> & {
        precision_threshold?: integer;
    };
    extended_stats: MetricAggregationConfig<Dataset, Fields>;
    geo_bounds: MetricAggregationConfig<Dataset, Fields> & {
        wrap_longitude?: boolean;
    };
    geo_centroid: MetricAggregationConfig<Dataset, Fields>;
    max: MetricAggregationConfig<Dataset, Fields>;
    min: MetricAggregationConfig<Dataset, Fields>;
    percentile_ranks: MetricAggregationConfig<Dataset, Fields> & {
    };
    percentiles: MetricAggregationConfig<Dataset, Fields> & {
        percents?: float[];
		hdr?: { 
            number_of_significant_value_digits: integer;
        };
    };
    scripted_metric: {
        init_script: Script;
        map_script: Script;
        combine_script: Script;
        reduce_script: Script;
    }
    stats: MetricAggregationConfig<Dataset, Fields>;
    string_stats: MetricAggregationConfig<Dataset, Fields> & {
        show_distribution?: boolean;
    };
    sum: MetricAggregationConfig<Dataset, Fields>;
    top_hits: {
		from?: integer;
		size?: integer;
		sort?: SortOptions<Dataset>;
		_source?: SourceOptions<Dataset>;
    };
    value_count: MetricAggregationConfig<Dataset, Fields>;
    weighted_avg: MetricAggregationConfig<Dataset, Fields> & {
        values: Dataset[Fields][];
    };
}

export type BucketAggregations<Dataset, Fields extends keyof Dataset> = {
    date_histogram: MetricAggregationConfig<Dataset, Fields> & {
        interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y';  // ES < 7
        // calendar_interval is for ES >= 7
        // calendar_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y'; 
        // fixed_interval is for ES >= 7 and also needs more thought
        // fixed_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y';
    };
    histogram: MetricAggregationConfig<Dataset, Fields> & {
        interval: Dataset[Fields];
    };
    missing:  MetricField<Dataset, Fields>;
    terms: MetricAggregationConfig<Dataset, Fields> & {

    };
}

export type MatrixAggregations<Dataset, Fields extends keyof Dataset> = {
    matrix_stats: {
        fields: Fields[]
        missing?: {
            [K in Fields]: Dataset[K];
        }
    }
}

export type Aggregations<Dataset, Fields extends keyof Dataset> =
    MetricAggregations<Dataset, Fields> &
    BucketAggregations<Dataset, Fields> /*& 
    MatrixAggregations<Dataset, Fields>*/;

type Aggregation<Dataset, DatasetField extends keyof Dataset> =
	ExactlyOne<Aggregations<Dataset, DatasetField>>;

type Aggs<Dataset, DatasetField extends keyof Dataset> = {
    [aggName: string]: Aggregation<Dataset, DatasetField> & {
        aggs?: Aggs<Dataset, DatasetField>;
    };
};
