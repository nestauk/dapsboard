// Utility types

type ExactlyOneOfSome<T, K extends keyof T = keyof T> = K extends unknown
    ? { 
        [I in keyof T]?: I extends K
            ? T[I]
            : never;
    }
    : never;

type ExactlyOne<T> = ExactlyOneOfSome<T, keyof T>;

// ElasticSearch Typings
// ElasticSearch Helper Types

export type ScriptLanguage = 'painless' | 'expression' | 'mustache' | 'java';

export type SortOrder = 'asc' | 'desc';

export type SortInstruction<Dataset> = 
    Record<keyof Dataset, SortOrder | { order: SortOrder }>;

export type SortOptions<Dataset> = 
    SortOrder | 
    SortInstruction<Dataset> | 
    SortInstruction<Dataset>[];

export type SourceOptions<Dataset> = string | string[];  //TODO incomplete


//Aggregation Helper Types

// This is a rather 'abstract' base interface
export type ScriptBase = {
	lang?: ScriptLanguage;
	params?: Record<string, string | number>;
}

export type LiteralScript = ScriptBase | {
	source: string;
}

export type ScriptReference = ScriptBase | {
	id: string;
}

// These are the actual values accepted by ES.
// Note that ScriptBase is not icluded
export type Script = {
    script: string | LiteralScript | ScriptReference;
}

export type MetricField<Dataset, Key extends keyof Dataset = keyof Dataset> = 
    Key extends keyof Dataset
        ? {
            /**
             * The field that values should be extracted from
             */
            field: Key;

            /**
             * A value to use if the field is missing entirely
             */
            missing?: Dataset[Key];
        }
        : never;

export type MetricAggregationConfig<Dataset, Keys extends keyof Dataset> = 
    MetricField<Dataset, Keys> /* | Script */;
// TODO Investigate why using the `Script` type above makes completions fail

export type MetricAggregations<Dataset, Fields extends keyof Dataset> = {
    /**
     * Computes the average of numeric values that are extracted from the
     * aggregated documents.
     */
    avg: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes boxplot of numeric values extracted from the aggregated
     * documents. 
     */
    boxplot: MetricAggregationConfig<Dataset, Fields> & {
        compression?: integer;
    };

    /**
     * Calculates an approximate count of distinct values.
     */
    cardinality: MetricAggregationConfig<Dataset, Fields> & {
        /**
         * allows to trade memory for accuracy, and defines a unique count below
         * which counts are expected to be close to accurate. Above this value,
         * counts might become a bit more fuzzy. The maximum supported value is
         * 40000, thresholds above this number will have the same effect as a
         * threshold of 40000. The default value is 3000.
         */
        precision_threshold?: integer;
    };

    /**
     * Computes stats over numeric values extracted from the aggregated
     * documents.
     */
    extended_stats: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes the bounding box containing all geo values for a field.
     */
    geo_bounds: MetricAggregationConfig<Dataset, Fields> & {
        /**
         * Specifies whether the bounding box should be allowed to overlap the
         * international date line.
         */
        wrap_longitude?: boolean;
    };

    /**
     * Computes the weighted centroid from all coordinate values for geo fields.
     */
    geo_centroid: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Returns the maximum value among the numeric values extracted from the
     * aggregated documents.
     */
    max: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Returns the minimum value among numeric values extracted from the
     * aggregated documents.
     */
    min: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Calculates one or more percentile ranks over numeric values extracted
     * from the aggregated documents.
     */
    percentile_ranks: MetricAggregationConfig<Dataset, Fields> & {
        values: number[];
        keyed?: boolean;
        hdr?: {
            number_of_significant_value_digits: integer;
        }
    };

    /**
     * Calculates one or more percentiles over numeric values extracted from the
     * aggregated documents. 
     */
    percentiles: MetricAggregationConfig<Dataset, Fields> & {
        percents?: float[];
		hdr?: { 
            number_of_significant_value_digits: integer;
        };
    };

    /**
     * A metric aggregation that executes using scripts to provide a metric
     * output.
     */
    scripted_metric: {
        init_script: Script;
        map_script: Script;
        combine_script: Script;
        reduce_script: Script;
    }

    /**
     * Computes stats over numeric values extracted from the aggregated
     * documents.
     */
    stats: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes statistics over string values extracted from the aggregated
     * documents.
     */
    string_stats: MetricAggregationConfig<Dataset, Fields> & {
        show_distribution?: boolean;
    };

    /**
     * Sums up numeric values that are extracted from the aggregated documents.
     */
    sum: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Performs a statistical hypothesis test in which the test statistic
     * follows a Studentâ€™s t-distribution under the null hypothesis on numeric 
     * values.
     */
    t_test: {
        a: MetricAggregationConfig<Dataset, Fields>;
        b: MetricAggregationConfig<Dataset, Fields>;
        type: 'paired' | 'homoscedastic' | 'heteroscedastic';
    }

    /**
     * Keeps track of the most relevant document being aggregated. This
     * aggregator is intended to be used as a sub aggregator, so that the top
     * matching documents can be aggregated per bucket.
     */
    top_hits: {
        /**
         * The offset from the first result you want to fetch.
         */
        from?: integer;

        /**
         * The maximum number of top matching hits to return per bucket. By
         * default the top three matching hits are returned.
         */
        size?: integer;

        /**
         * How the top matching hits should be sorted. By default the hits are
         * sorted by the score of the main query.
         */
        sort?: SortOptions<Dataset>;
        
        /**
         * Field names
         */
		_source?: SourceOptions<Dataset>;
    };

    /**
     * Selects metrics from the document with the largest or smallest "sort"
     * value.
     */
    top_metrics: {
        /**
         * Selects the fields of the "top" document to return. You can request a
         * single metric with something like "metric": {"field": "m"} or
         * multiple metrics by requesting a list of metrics like "metric": 
         * [{"field": "m"}, {"field": "i"}.
         */
        metrics: MetricAggregationConfig<Dataset, Fields>;

        /**
         * Allows you to add one or more sorts on specific fields. Each sort can
         * be reversed as well. The sort is defined on a per field level, with
         * special field name for _score to sort by score, and _doc to sort by
         * index order.
         */
        sort: SortOptions<Dataset>;

        /**
         * The maximum number of top matching hits to return per bucket. By
         * default the top three matching hits are returned.
         */
        size?: integer;
    }

    /**
     * Counts the number of values that are extracted from the aggregated
     * documents.
     */
    value_count: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes the weighted average of numeric values that are extracted from
     * the aggregated documents.
     */
    weighted_avg: {
        /**
         * The configuration for the field or script that provides the values
         */
        value: MetricAggregationConfig<Dataset, Fields>;

        /**
         * The configuration for the field or script that provides the weights
         */
        weight: MetricAggregationConfig<Dataset, Fields>;

        /**
         * A hint about the values for pure scripts or unmapped fields
         */
        format?: any; // TODO figure out data type
        value_type?: any; // TODO figure out data type
    };
}

export type BucketAggregations<Dataset, Fields extends keyof Dataset> = {
    /**
     * A bucket aggregation returning a form of adjacency matrix. The request
     * provides a collection of named filter expressions, similar to the filters
     * aggregation request.
     */
    adjacency_matrix: {
        filters: Record<string, {
            terms: Record<Fields,string[]>;
        }>;
    };

    /**
     * A special single bucket aggregation that selects child documents that
     * have the specified type, as defined in a join field.
     */
    children: {
		/**
		 * Points to type / mapping with the value as name
		 */
        type: string;
    };

    /**
     * A multi-bucket aggregation that creates composite buckets from different
     * sources.
     */
    composite: {
        sources: Record<string, {
            terms: MetricAggregationConfig<Dataset, Fields> & {
				/**
				 * By default, the terms aggregation will return the buckets for the top
				 * ten terms ordered by the doc_count. One can change this default
				 * behaviour by setting the size parameter.
				 */
				size: integer;
			};
        }>[];
    };

    /**
     * This multi-bucket aggregation is similar to the normal histogram, but it
     * can only be used with date values. Because dates are represented
     * internally in Elasticsearch as long values, it is possible, but not as
     * accurate, to use the normal histogram on dates as well.
     */
    date_histogram: MetricAggregationConfig<Dataset, Fields> & {
        interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y';  // ES < 7
        // calendar_interval is for ES >= 7
        // calendar_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y'; 
        // fixed_interval is for ES >= 7 and also needs more thought
        // fixed_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y';
    };

    /**
     * A range aggregation that is dedicated for date values. The main
     * difference between this aggregation and the normal range aggregation is
     * that the from and to values can be expressed in Date Math expressions,
     * and it is also possible to specify a date format by which the from and to
     * response fields will be returned.
     */
    date_range: MetricAggregationConfig<Dataset, Fields> & {
        format: string;
        ranges: {
            key?: string;
            from?: string;
            to?: string;
        }
    };

    /**
     * Like the sampler aggregation this is a filtering aggregation used to
     * limit any sub aggregations' processing to a sample of the top-scoring
     * documents. The diversified_sampler aggregation adds the ability to limit
     * the number of matches that share a common value such as an "author".
     */
    diversified_sampler: MetricAggregationConfig<Dataset, Fields> & {
        shard_size?: integer;
        max_docs_per_value?: integer;
        execution_hint?: 'map' | 'global_ordinals' | 'bytes_hash';
    };

    /**
     * Defines a single bucket of all the documents in the current document set
     * context that match a specified filter. Often this will be used to narrow
     * down the current aggregation context to a specific set of documents.
     */
    filter: {

    };

    /**
     * Defines a multi bucket aggregation where each bucket is associated with a
     * filter. Each bucket will collect all documents that match its associated
     * filter.
     */
    filters: {
        /**
         * can be set to add a bucket to the response which will contain all
         * documents that do not match any of the given filters.
         */
        other_bucket?: boolean;

        /**
         * can be used to set the key for the other bucket to a value other than
         * the default _other_. Setting this parameter will implicitly set the
         * other_bucket parameter to true.
         */
        other_bucket_key?: string;
        filters: {

        }[];
    }

    /**
     * A multi-bucket aggregation that works on geo_point fields and
     * conceptually works very similar to the range aggregation. The user can
     * define a point of origin and a set of distance range buckets.
     */
    geo_distance: MetricAggregationConfig<Dataset, Fields> & {
        origin: string;
        ranges: {}[];
    }

    /**
     * A multi-bucket aggregation that works on geo_point fields and groups
     * points into buckets that represent cells in a grid. The resulting grid
     * can be sparse and only contains cells that have matching data.
     */
    geo_hash: {
        /**
         * The name of the field indexed with GeoPoints.
         */
        field: Fields;

        /**
         * The string length of the geohashes used to define cells/buckets in
         * the results. Defaults to 5. 
         */
        precision?: integer | string;

        /**
         * The maximum number of geohash buckets to return (defaults to 10,000).
         */
        size?: integer;

        /**
         * To allow for more accurate counting of the top cells returned in the
         * final result the aggregation defaults to returning max(10,(size x
         * number-of-shards)) buckets from each shard. If this heuristic is
         * undesirable, the number considered from each shard can be over-ridden
         * using this parameter.
         */
        shard_size?: integer;
    }

    /**
     * Defines a single bucket of all the documents within the search execution
     * context. This context is defined by the indices and the document types
     * youâ€™re searching on, but is not influenced by the search query itself.
     */
    global: {};

    /**
     * A multi-bucket values source based aggregation that can be applied on
     * numeric values extracted from the documents.
     */
    histogram: MetricAggregationConfig<Dataset, Fields> & {
        /**
         * Must be a positive decimal.
         */
        interval: Dataset[Fields];

        /**
         * Must be a decimal greater than or equal to 0 and less than interval.
         */
        offset?: Dataset[Fields];

        /**
         * y default the response will fill gaps in the histogram with empty
         * buckets. It is possible change that and request buckets with a higher
         * minimum count thanks to the min_doc_count setting.
         */
        min_doc_count?: integer;

        /**
         * By default, the buckets are returned as an ordered array. It is also
         * possible to request the response as a hash instead keyed by the
         * buckets keys.
         */
        keyed?: boolean;
    };

    /**
     * A dedicated range aggregation for IP typed fields.
     */
    ip_ranges: MetricAggregationConfig<Dataset, Fields> & {

    }

    /**
     * A field data based single bucket aggregation, that creates a bucket of
     * all documents in the current document set context that are missing a
     * field value (effectively, missing a field or having the configured NULL
     * value set).
     */
    missing:  MetricField<Dataset, Fields>;

    /**
     * A special single bucket aggregation that enables aggregating nested
     * documents.
     */
    nested: {
        /**
         * Path of the nested documents within the top level documents.
         */
        path: string;
    }

    /**
     * A multi-bucket value source based aggregation that enables the user to
     * define a set of ranges - each representing a bucket.
     */
    range: MetricAggregationConfig<Dataset, Fields> & {
        ranges: {

        }[];
    }

    /**
     * A special single bucket aggregation that enables aggregating on parent
     * docs from nested documents. Effectively this aggregation can break out of
     * the nested block structure and link to other nested structures or the
     * root document, which allows nesting other aggregations that arenâ€™t part
     * of the nested object in a nested aggregation.
     */
    reverse_nested: {
        /**
         * Path of the nested documents within the top level documents.
         */
        path?: string;
    }

    /**
     * A filtering aggregation used to limit any sub aggregations' processing to
     * a sample of the top-scoring documents.
     */
    sampler: {
        shard_size?: integer;
    }

    /**
     * An aggregation that returns interesting or unusual occurrences of terms
     * in a set.
     */
    significant_terms: MetricAggregationConfig<Dataset, Fields> & {
        min_doc_count?: integer;
        background_filter?: {
            term: any;
        }
    };

    /**
     * An aggregation that returns interesting or unusual occurrences of
     * free-text terms in a set.
     */
    significant_text: MetricAggregationConfig<Dataset, Fields> & {
        filter_duplicate_text?: boolean;
        background_filter?: {
            term: any;
        }
        source_fields?: Fields[];
    }

    /**
     * A multi-bucket value source based aggregation where buckets are 
     * dynamically built - one per unique value.
     */
    terms: MetricAggregationConfig<Dataset, Fields> & {
        /**
         * By default, the terms aggregation will return the buckets for the top
         * ten terms ordered by the doc_count. One can change this default
         * behaviour by setting the size parameter.
         */
        size: integer;
    };
}

export type MatrixAggregations<Dataset, Fields extends keyof Dataset> = {
    matrix_stats: {
        fields: Fields[]
        missing?: {
            [K in Fields]: Dataset[K];
        }
    }
}

export type Aggregations<Dataset, Fields extends keyof Dataset> =
    MetricAggregations<Dataset, Fields> &
    BucketAggregations<Dataset, Fields> /*& 
    MatrixAggregations<Dataset, Fields>*/;

type Aggregation<Dataset, DatasetField extends keyof Dataset> =
	ExactlyOne<Aggregations<Dataset, DatasetField>>;

type Aggs<Dataset, DatasetField extends keyof Dataset> = {
    [aggName: string]: Aggregation<Dataset, DatasetField> & {
        aggs?: Aggs<Dataset, DatasetField>;
    };
};
