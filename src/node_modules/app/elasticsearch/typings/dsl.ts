// Utility types

type ExactlyOneOfSome<T, K extends keyof T = keyof T> = K extends unknown
    ? { 
        [I in keyof T]?: I extends K
            ? T[I]
            : never;
    }
    : never;

type ExactlyOne<T> = ExactlyOneOfSome<T, keyof T>;

// ElasticSearch Typings
// ElasticSearch Helper Types

export type ScriptLanguage = 'painless' | 'expression' | 'mustache' | 'java';

export type SortOrder = 'asc' | 'desc';

export type SortInstruction<Dataset> = 
    Record<keyof Dataset, SortOrder | { order: SortOrder }>;

export type SortOptions<Dataset> = 
    SortOrder | 
    SortInstruction<Dataset> | 
    SortInstruction<Dataset>[];

export type SourceOptions<Dataset> = string | string[];  //TODO incomplete


//Aggregation Helper Types

// This is a rather 'abstract' base interface
export type ScriptBase = {
	lang?: ScriptLanguage;
	params?: Record<string, string | number>;
}

export type LiteralScript = ScriptBase | {
	source: string;
}

export type ScriptReference = ScriptBase | {
	id: string;
}

// These are the actual values accepted by ES.
// Note that ScriptBase is not icluded
export type Script = {
    script: string | LiteralScript | ScriptReference;
}

export type MetricField<Dataset, Key extends keyof Dataset = keyof Dataset> = 
    Key extends keyof Dataset
        ? {
            /**
             * The field that values should be extracted from
             */
            field: Key;

            /**
             * A value to use if the field is missing entirely
             */
            missing?: Dataset[Key];
        }
        : never;

export type MetricAggregationConfig<Dataset, Keys extends keyof Dataset> = 
    MetricField<Dataset, Keys> /* | Script */;
// TODO Investigate why using the `Script` type above makes completions fail

export type MetricAggregations<Dataset, Fields extends keyof Dataset> = {
    /**
     * Computes the average of numeric values that are extracted from the
     * aggregated documents.
     */
    avg: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes boxplot of numeric values extracted from the aggregated
     * documents. 
     */
    boxplot: MetricAggregationConfig<Dataset, Fields> & {
        compression?: integer;
    };

    /**
     * Calculates an approximate count of distinct values.
     */
    cardinality: MetricAggregationConfig<Dataset, Fields> & {
        /**
         * allows to trade memory for accuracy, and defines a unique count below
         * which counts are expected to be close to accurate. Above this value,
         * counts might become a bit more fuzzy. The maximum supported value is
         * 40000, thresholds above this number will have the same effect as a
         * threshold of 40000. The default value is 3000.
         */
        precision_threshold?: integer;
    };

    /**
     * Computes stats over numeric values extracted from the aggregated
     * documents.
     */
    extended_stats: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes the bounding box containing all geo values for a field.
     */
    geo_bounds: MetricAggregationConfig<Dataset, Fields> & {
        /**
         * Specifies whether the bounding box should be allowed to overlap the
         * international date line.
         */
        wrap_longitude?: boolean;
    };

    /**
     * Computes the weighted centroid from all coordinate values for geo fields.
     */
    geo_centroid: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Returns the maximum value among the numeric values extracted from the
     * aggregated documents.
     */
    max: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Returns the minimum value among numeric values extracted from the
     * aggregated documents.
     */
    min: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Calculates one or more percentile ranks over numeric values extracted
     * from the aggregated documents.
     */
    percentile_ranks: MetricAggregationConfig<Dataset, Fields> & {
        values: number[];
        keyed?: boolean;
        hdr?: {
            number_of_significant_value_digits: integer;
        }
    };

    /**
     * Calculates one or more percentiles over numeric values extracted from the
     * aggregated documents. 
     */
    percentiles: MetricAggregationConfig<Dataset, Fields> & {
        percents?: float[];
		hdr?: { 
            number_of_significant_value_digits: integer;
        };
    };

    /**
     * A metric aggregation that executes using scripts to provide a metric
     * output.
     */
    scripted_metric: {
        init_script: Script;
        map_script: Script;
        combine_script: Script;
        reduce_script: Script;
    }

    /**
     * Computes stats over numeric values extracted from the aggregated
     * documents.
     */
    stats: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes statistics over string values extracted from the aggregated
     * documents.
     */
    string_stats: MetricAggregationConfig<Dataset, Fields> & {
        show_distribution?: boolean;
    };

    /**
     * Sums up numeric values that are extracted from the aggregated documents.
     */
    sum: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Performs a statistical hypothesis test in which the test statistic follows
     * a Studentâ€™s t-distribution under the null hypothesis on numeric values.
     */
    t_test: {
        a: MetricAggregationConfig<Dataset, Fields>;
        b: MetricAggregationConfig<Dataset, Fields>;
        type: 'paired' | 'homoscedastic' | 'heteroscedastic';
    }

    /**
     * Keeps track of the most relevant document being aggregated. This
     * aggregator is intended to be used as a sub aggregator, so that the top
     * matching documents can be aggregated per bucket.
     */
    top_hits: {
        /**
         * The offset from the first result you want to fetch.
         */
        from?: integer;

        /**
         * The maximum number of top matching hits to return per bucket. By
         * default the top three matching hits are returned.
         */
        size?: integer;

        /**
         * How the top matching hits should be sorted. By default the hits are
         * sorted by the score of the main query.
         */
        sort?: SortOptions<Dataset>;
        
        /**
         * Field names
         */
		_source?: SourceOptions<Dataset>;
    };

    /**
     * Selects metrics from the document with the largest or smallest "sort"
     * value.
     */
    top_metrics: {
        /**
         * Selects the fields of the "top" document to return. You can request a
         * single metric with something like "metric": {"field": "m"} or
         * multiple metrics by requesting a list of metrics like "metric": 
         * [{"field": "m"}, {"field": "i"}.
         */
        metrics: MetricAggregationConfig<Dataset, Fields>;

        /**
         * Allows you to add one or more sorts on specific fields. Each sort can
         * be reversed as well. The sort is defined on a per field level, with
         * special field name for _score to sort by score, and _doc to sort by
         * index order.
         */
        sort: SortOptions<Dataset>;

        /**
         * The maximum number of top matching hits to return per bucket. By
         * default the top three matching hits are returned.
         */
        size?: integer;
    }

    /**
     * Counts the number of values that are extracted from the aggregated
     * documents.
     */
    value_count: MetricAggregationConfig<Dataset, Fields>;

    /**
     * Computes the weighted average of numeric values that are extracted from
     * the aggregated documents.
     */
    weighted_avg: {
        /**
         * The configuration for the field or script that provides the values
         */
        value: MetricAggregationConfig<Dataset, Fields>;

        /**
         * The configuration for the field or script that provides the weights
         */
        weight: MetricAggregationConfig<Dataset, Fields>;

        /**
         * A hint about the values for pure scripts or unmapped fields
         */
        format?: any; // TODO figure out data type
        value_type?: any; // TODO figure out data type
    };
}

export type BucketAggregations<Dataset, Fields extends keyof Dataset> = {
    adjacency_matrix: {
        filters: {
            
        }
    }
    date_histogram: MetricAggregationConfig<Dataset, Fields> & {
        interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y';  // ES < 7
        // calendar_interval is for ES >= 7
        // calendar_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y'; 
        // fixed_interval is for ES >= 7 and also needs more thought
        // fixed_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y';
    };
    histogram: MetricAggregationConfig<Dataset, Fields> & {
        interval: Dataset[Fields];
    };
    missing:  MetricField<Dataset, Fields>;
    terms: MetricAggregationConfig<Dataset, Fields> & {

    };
}

export type MatrixAggregations<Dataset, Fields extends keyof Dataset> = {
    matrix_stats: {
        fields: Fields[]
        missing?: {
            [K in Fields]: Dataset[K];
        }
    }
}

export type Aggregations<Dataset, Fields extends keyof Dataset> =
    MetricAggregations<Dataset, Fields> &
    BucketAggregations<Dataset, Fields> /*& 
    MatrixAggregations<Dataset, Fields>*/;

type Aggregation<Dataset, DatasetField extends keyof Dataset> =
	ExactlyOne<Aggregations<Dataset, DatasetField>>;

type Aggs<Dataset, DatasetField extends keyof Dataset> = {
    [aggName: string]: Aggregation<Dataset, DatasetField> & {
        aggs?: Aggs<Dataset, DatasetField>;
    };
};
