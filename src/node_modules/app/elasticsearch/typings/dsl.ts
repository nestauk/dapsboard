// Utility types

type ExactlyOneOfSome<T, K extends keyof T = keyof T> = K extends unknown ?
    { 
        [I in keyof T]?: I extends K ?
            T[I] :
            never;
    } : 
    never;

type ExactlyOne<T> = ExactlyOneOfSome<T, keyof T>;

// ElasticSearch Typings
// ElasticSearch Helper Types

export type ScriptLanguage = 'painless' | 'expression' | 'mustache' | 'java';

export type SortOrder = 'asc' | 'desc';

export type SortInstruction<Dataset> = 
    Record<keyof Dataset, SortOrder | { order: SortOrder }>;

export type SortOptions<Dataset> = 
    SortOrder | 
    SortInstruction<Dataset> | 
    SortInstruction<Dataset>[];

export type SourceOptions<Dataset> = string | string[];  //TODO incomplete


//Aggregation Helper Types

// This is a rather 'abstract' base interface
export type ScriptBase = {
	lang?: ScriptLanguage;
	params?: Record<string, string | number>;
}

export type LiteralScript = ScriptBase | {
	source: string;
}

export type ScriptReference = ScriptBase | {
	id: string;
}

// These are the actual values accepted by ES.
// Note that ScriptBase is not icluded
export type Script = {
    script: string | LiteralScript | ScriptReference;
}

export type MetricField<Dataset, Key extends keyof Dataset = keyof Dataset> = 
    Key extends keyof Dataset ?
        {
            field: Key;
            missing?: Dataset[Key];
        } :
            never;

export type MetricAggregationConfig<Dataset, Keys extends keyof Dataset> = 
    MetricField<Dataset, Keys> | Script;


export type MetricAggregations<Dataset, Fields extends keyof Dataset> = {
    avg: MetricAggregationConfig<Dataset, Fields>;
    cardinality: MetricAggregationConfig<Dataset, Fields> & {
        precision_threshold?: number;
    };
    extended_stats: MetricAggregationConfig<Dataset, Fields>;
    geo_bounds: MetricAggregationConfig<Dataset, Fields> & {
        wrap_longitude?: boolean;
    };
    geo_centroid: MetricAggregationConfig<Dataset, Fields>;
    max: MetricAggregationConfig<Dataset, Fields>;
    min: MetricAggregationConfig<Dataset, Fields>;
    percentile_ranks: MetricAggregationConfig<Dataset, Fields> & {
    };
    percentiles: MetricAggregationConfig<Dataset, Fields> & {
        percents?: number[];
		hdr?: { 
            number_of_significant_value_digits: number;
        };
    };
    scripted_metric: {
        init_script: Script;
        map_script: Script;
        combine_script: Script;
        reduce_script: Script;
    }
    stats: MetricAggregationConfig<Dataset, Fields>;
    string_stats: MetricAggregationConfig<Dataset, Fields> & {
        show_distribution?: boolean;
    };
    sum: MetricAggregationConfig<Dataset, Fields>;
    top_hits: {
		from?: number;
		size?: number;
		sort?: SortOptions<Dataset>;
		_source?: SourceOptions<Dataset>;
    };
    value_count: MetricAggregationConfig<Dataset, Fields>;
    weighted_avg: MetricAggregationConfig<Dataset, Fields> & {
        values: Dataset[Fields][];
    };
}

export type BucketAggregations<Dataset, Fields extends keyof Dataset> = {
    date_histogram: MetricAggregationConfig<Dataset, Fields> & {
        interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y';  // ES < 7
        //calendar_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y'; // ES >= 7
        //fixed_interval: '1m' | '1h' | '1d' | '1w' | '1M' | '1q' | '1y'; // ES >= 7 and also needs more thought
    };
    histogram: MetricAggregationConfig<Dataset, Fields> & {
        interval: number;
    };
    missing:  MetricField<Dataset, Fields>;
    terms: MetricAggregationConfig<Dataset, Fields> & {

    };
}

export type MatrixAggregations<Dataset, Fields extends keyof Dataset> = {
    matrix_stats: {
        fields: Fields[]
        missing?: {
            [K in Fields]: Dataset[K];
        }
    }
}

export type Aggregations<Dataset, Fields extends keyof Dataset> =
    MetricAggregations<Dataset, Fields> &
    BucketAggregations<Dataset, Fields> & 
    MatrixAggregations<Dataset, Fields>;

type Aggregation<Dataset, DatasetField extends keyof Dataset> =
	ExactlyOne<Aggregations<Dataset, DatasetField>>;

type Aggs<Dataset, DatasetField extends keyof Dataset> = {
    [aggName: string]: Aggregation<Dataset, DatasetField> & {
        aggs?: Aggs<Dataset, DatasetField>;
    };
};
