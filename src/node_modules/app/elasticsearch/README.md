## Type system

The type system is currently used for generating request forms and may
eventually also be used for validation prior to sending the requests.

It draws its inspiration from many features available in Typescript offering
support for such things as type unions, generics and string literal types. It
does however offer additional support for special types useful in composing
Elasticsearch query requests.

### Types

#### Named types

Named types are defined using strings. The following 'native' types are
backed by form editor components:

* `boolean`
* Numeric types: `number`, `integer`, `float`
* Alphanumeric types: `string`, `ES_Text`, `ES_keyword`, `ES_Text_w_keyword`
* Date types: `date`, `Date_YYYYMMDD_dash`, `Date_YYYYMMDD_dash_time` (time not
  presently editable)
* Object types: `json`, `MinMax<float>`, `MinMax<integer>`

```javascript
const someAggregationParams = {
  size: 'float', // defining a `size` request parameter if `float` type
  count: 'integer', // defining a parameter of `float` type
  name: 'string', // defining a parameter of 'string' type
  date: 'Date_YYYYMMDD_dash', // Will present the user with a date editor
  someParam: 'json' // the value will be parsed as json and added to the request
}
```

#### String Literals

String literal types are strings whose first and last characters are double 
quotes `"`. They're mainly used in conjunction with type unions which are
explained  immediately below.

#### Type unions

Sometimes a request parameter can have values of differing type. This can be
specified in the type system with a type union, which is represented by an
array of types.

* Type unions are defined using arrays.
* Compound types are defined using objects.
* Generic types can be specified by providing a function whose arguments are
  the generic type arguments. At this time, generics is limited to a single
  generic type, which is all that is needed for Elasticsearch requests.
* Arrays of named types are strings ending with `[]`.
* Arrays can also be defined with objects having a single `__array` property
  whose value is the type of the array.
* Physical quantities (numbers with units), can be specified with an object 
  having a single `__units` property whose values is an array of strings
  defining the possible units that can be used.
* Record types, which essentialy allow for named lists, can be specified with
  an object having a `__record` property specifying the type of the item names
  and a `__type` property specifying the type of the item values.
* Other properties starting with `__` and specify mutually exclusive parameters.
* Type objects can include a `__legacyName` property to help in form generation
  upstream.
* Properties can be defined as optional by specifying the type in a type union
  accompanied with the `undefined` type. The `null` type may also be supported 
  at a later time.

## Example type definitions
```javascript
const someAggregationParams = {
  size: 'float', // defining a `size` request parameter if `float` type
  count: 'integer', // defining a parameter of `float` type
  name: 'string', // defining a parameter of 'string' type
  date: 'date'
}
```

## ElasticSearch Aggregation Composition Rules

* Metric aggregations can't have children
* Most bucketing aggregations can have other bucketing or metric
  aggregations as children.
* The `Global` aggregator can only be top level.
* The `Reverse Nested` aggregator can only be defined inside a `Nested`
  aggregation.
* The `Significant Text` aggregation can be used anywhere but:
  > Re-analyzing large result sets will require a lot of time and memory. It is
  > recommended that the `significant_text` aggregation is used as a child of
  > either the `sampler` or `diversified sampler` aggregation to limit the
  > analysis to a small selection of top-matching documents e.g. 200. This will
  > typically improve speed, memory use and quality of results.
