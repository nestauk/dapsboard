import * as _ from 'lamb';
import {
	hasIterableLength1,
	isArray,
	isObject,
	isString,
	makeEndsWith,
	makeMergeAppliedFnMap,
	makeStartsWith,
	valuesWith,
} from '@svizzle/utils';

import aggParamsDefaults from 'app/elasticsearch/config/aggParamsDefaults';
import {aggParamShapeByAggId} from 'app/elasticsearch/config/aggParamShapeByAggId';
import aggParamDocByAggId from 'app/elasticsearch/config/aggParamDocByAggId';
import {evaluate} from 'app/utils/generic';

const hasLegacyName = _.hasKey('__legacyName');
const isRequired = _.not(_.allOf([isArray, _.contains('undefined')]));
const isStringLiteral = _.allOf([isString, makeStartsWith('"')]);

export const equalsJson = _.is('json');
export const hasRecord = _.hasKey('__record');
export const hasUnits = _.hasKey('__units');
export const isArrayObject = _.hasKey('__array');
export const isArrayString = _.allOf([isString, makeEndsWith('[]')]);
export const isStringLiteralUnion = _.allOf([
	isArray,
	_.every(_.anyOf([
		_.is('undefined'),
		isStringLiteral
	]))
]);

function getDisplayType (fullType, indentation = 0) {
	if (isString(fullType)) {
		return fullType;
	}
	if (isArray(fullType)) {
		return fullType
		.filter(type => type !== 'undefined')
		.map(type => getDisplayType(type, indentation + 1))
		.join(' | ');
	}
	if (isObject(fullType)) {
		if (isArrayObject(fullType)) {
			return `${getDisplayType(fullType.__array, indentation + 1)}[]`;
		}
		if (hasLegacyName(fullType)) {
			return fullType.__legacyName;
		}
		const paramNames = Object.keys(fullType);
		const result = paramNames
		.map(name => {
			return `${'\t'.repeat(indentation)}${name}: ${getDisplayType(fullType[name], indentation + 1)};`;
		})
		.join('\n');
		return ['{\n', result, '\n', '\t'.repeat(indentation >= 1 ? indentation - 1 : 0), '}'].join('');
	}
	return '';
}

const getParamInfo = valuesWith(
	(paramType, name) => ({
		name,
		type: paramType,
		required: isRequired(paramType),
		displayText: getDisplayType(paramType),
	})
);

const revealTypeWith = defaults => _.pipe([
	_.pull(defaults),
	_.when(hasIterableLength1, _.head)
]);
const revealType = revealTypeWith(['undefined']);

export const extractBaseType = _.when(isArray, revealType);

export const getTypings = _.pipe([
	extractBaseType,
	getParamInfo,
	_.sortWith([_.getKey('required')])
]);

const mergeDocs = (info, docs) =>
	info.map(makeMergeAppliedFnMap({
		documentation: param => docs[param.name]
	}));

export function getParamsByAgg (agg, type) {
	const params = aggParamShapeByAggId[agg];
	const computedParams = evaluate(type)(params);
	const info = getParamInfo(computedParams);
	const docs = aggParamDocByAggId[agg];
	return mergeDocs(info, docs);
}

export function getAggParamDefaultValue (aggregation, dataset, field, type, parameter) {
	if (!(aggregation in aggParamsDefaults)) {
		return undefined;
	}
	const agg = aggParamsDefaults[aggregation];
	if (!(parameter in agg)) {
		return undefined;
	}
	const defaultValue = agg[parameter]
	if (typeof defaultValue !== 'function') {
		return defaultValue;
	}
	const computedValue = defaultValue(dataset, field, type);
	if (computedValue && computedValue.then && typeof computedValue.then === 'function') {
		// TODO wait until promise resolution
	} else {
		return computedValue;
	}
	return undefined;
}
