import * as _ from 'lamb';

import {aggregationsPerType} from './config';

export function determineESType (field) {
	if (typeof field === 'string') {
		return field;
	}

	if (typeof field === 'object') {
		if ('es_type' in field) {
			return field.es_type;
		}
		if ('data_type' in field) {
			return field.data_type;
		}
		if ('type' in field) {
			return field.type;
		}

		// TODO: Should we throw or simply return 'object'?
		// throw new Error('Bad type specification');
	}

	return 'object';
}

const hasKeywordField = _.anyOf([
	_.is('ES_text_w_keyword'),
	_.is('ES_text_w_keyword[]'),
]);

const createKeywordFieldQuery = fieldName => ({field: `${fieldName}.keyword`});

function defaultAggregationFactory (fieldName, fieldInfo) {
	const fieldType = determineESType(fieldInfo);
	if (hasKeywordField(fieldType)) {
		return createKeywordFieldQuery(fieldName);
	}
	return { field: fieldName };
}

const queryFactories = {
	// eslint-disable-next-line no-unused-vars
	weighted_avg: (fieldName, fieldInfo) => {
		return {
			value: { field: fieldName },
			weight: { script: '1'}
		};
	}
}

export function buildAggregation (aggregation, fieldName, fieldInfo) {
	if (aggregation in queryFactories) {
		return queryFactories[aggregation](fieldName, fieldInfo);
	}

	return defaultAggregationFactory(fieldName, fieldInfo);
}

export function constructQuery (schema) {
	const aggs = {};
	for (let f in schema) {
		const fType = determineESType(schema[f]);
		const typeAggs = aggregationsPerType[fType];
		for (let i in typeAggs) {
			const at = typeAggs[i];
			const atName = `${f}_${at}`;
			aggs[atName] = {
				[at]: buildAggregation(at, f, schema[f])
			};
		}
	}

	return {
		size: 0,
		aggs
	};
}
