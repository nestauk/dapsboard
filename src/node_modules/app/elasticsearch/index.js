import * as _ from 'lamb';
import {
	isArray,
	isString,
	isObject,
	hasIterableLength1,
	makeStartsWith,
	makeEndsWith
} from '@svizzle/utils';

import {
	aggsByType,
	defaultValues,
	paramsByAggs
} from './config';

const ifExistsGet = prop => _.casus(_.hasKey(prop), _.getKey(prop));

export const getESType = _.adapter([
	_.casus(isString, _.identity),
	_.casus(isObject, _.adapter([
		ifExistsGet('es_type'),
		ifExistsGet('data_type'),
		ifExistsGet('type'),
	])),
	_.always('object')
]);

const revealTypeWith = defaults => _.pipe([
	_.pull(defaults),
	_.when(hasIterableLength1, _.head)
]);
const revealType = revealTypeWith(['undefined']);
export const extractBaseType = _.when(isArray, revealType);

const isStringLiteral = _.allOf([isString, makeStartsWith('"')]);
export const isStringLiteralUnion = _.allOf([
	isArray,
	_.every(_.anyOf([
		_.is('undefined'),
		isStringLiteral
	]))
]);

export const isRequired = _.not(_.allOf([isArray, _.contains('undefined')]));
export const isArrayObject = _.hasKey('__array');
export const isArrayString = _.allOf([isString, makeEndsWith('[]')]);
export const equalsJson = _.is('json');
export const hasRecord = _.hasKey('__record');

function getDisplayType (fullType, indentation = 0) {
	if (isString(fullType)) {
		return fullType;
	}
	if (isArray(fullType)) {
		return fullType
		.filter(type => type !== 'undefined')
		.map(type => getDisplayType(type, indentation + 1))
		.join(' | ');
	}
	if (isObject(fullType)) {
		if ('__array' in fullType) {
			return `${getDisplayType(fullType.__array, indentation + 1)}[]`;
		}
		if ('__legacyName' in fullType) {
			return fullType.__legacyName;
		}
		const paramNames = Object.keys(fullType);
		const result = paramNames
		.map(name => {
			return `${'\t'.repeat(indentation)}${name}: ${getDisplayType(fullType[name], indentation + 1)};`;
		})
		.join('\n');
		return ['{\n', result, '\n', '\t'.repeat(indentation >= 1 ? indentation - 1 : 0), '}'].join('');
	}
	return '';
}

export const getParamInfo = _.pipe([
	_.mapValuesWith((paramType, name) => ({
		name,
		type: paramType,
		required: isRequired(paramType),
		displayText: getDisplayType(paramType),
		documentation: ['']
	})),
	_.values
]);

const isFunction = _.isType('Function');

export function getParamsByAgg (agg, type) {
	const params = paramsByAggs[agg];
	const computedParams = isFunction(params) ? params(type) : params;
	return getParamInfo(computedParams);
}

const hasKeywordField = _.anyOf([
	_.is('ES_text_w_keyword'),
	_.is('ES_text_w_keyword[]'),
]);

const createKeywordFieldQuery = fieldName => ({field: `${fieldName}.keyword`});

function defaultAggregationFactory (fieldName, fieldInfo) {
	const fieldType = getESType(fieldInfo);
	if (hasKeywordField(fieldType)) {
		return createKeywordFieldQuery(fieldName);
	}
	return { field: fieldName };
}

const queryFactories = {
	composite: () => ({}),
	filter: () => ({}),
	filters: () => ({}),
	sampler: () => ({}),
	// eslint-disable-next-line no-unused-vars
	weighted_avg: () => ({})
}

export function buildAggregation (aggregation, fieldName, fieldInfo) {
	if (aggregation in queryFactories) {
		return queryFactories[aggregation](fieldName, fieldInfo);
	}

	return defaultAggregationFactory(fieldName, fieldInfo);
}

export function constructQuery (schema) {
	const aggs = {};
	for (let f in schema) {
		const fType = getESType(schema[f]);
		const typeAggs = aggsByType[fType];
		for (let i in typeAggs) {
			const at = typeAggs[i];
			const atName = `${f}_${at}`;
			aggs[atName] = {
				[at]: buildAggregation(at, f, schema[f])
			};
		}
	}

	return {
		size: 0,
		aggs
	};
}

export function getDefaultValue (aggregation, dataset, field, type, parameter) {
	if (!(aggregation in defaultValues)) {
		return undefined;
	}
	const agg = defaultValues[aggregation];
	if (!(parameter in agg)) {
		return undefined;
	}
	const defaultValue = agg[parameter]
	if (typeof defaultValue !== 'function') {
		return defaultValue;
	}
	const computedValue = defaultValue(dataset, field, type);
	if (computedValue && computedValue.then && typeof computedValue.then === 'function') {
		// TODO wait until promise resolution
	} else {
		return computedValue;
	}
	return undefined;
}
