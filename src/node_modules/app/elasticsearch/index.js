export const metricDescriptionsEN = {
	avg: "Average",
	// weighted_avg: "Weighted Average",
	cardinality: "Cardinality",
	extended_stats: "Extended Statistics",
	geo_bounds: "Geographic Bounds",
	geo_centroid: "Geographic Centroid",
	max: "Maximum",
	min: "Minimum",
	percentiles: "Percentiles",
	// percentile_ranks: "Percentile Ranks",
	// scripted_metric: "Scripted Metric",
	stats: "Statistics",
	// string_stats: "String Statistics",
	sum: "Sum",
	// top_hits: "Top Hits",
	value_count: "Value Count",
	// median_absolute_deviation: "Median Absolute Deviation"
}

export const bucketDescriptionsEN = {
	histogram: "Histogram",
	date_histogram: "Date Histogram",
	missing: "Missing",
	terms: "Terms"
}

export const aggregationsPerType = {
	boolean: [
		'avg',
		'cardinality',
		'max',
		'min',
		'missing',
		'stats',
		'sum',
		'value_count',
		// 'percentile_ranks',
	],
	date: [
		'avg',
		'cardinality',
		'date_histogram',
		'extended_stats',
		'max',
		'min',
		'missing',
		'percentiles',
		'stats',
		'sum',
		'terms',
		'value_count',
		// 'percentile_ranks',
	],
	Date_YYYYMMDD_dash: [
		'avg',
		'cardinality',
		'date_histogram',
		'extended_stats',
		'max',
		'min',
		'missing',
		'percentiles',
		'stats',
		'sum',
		'terms',
		'value_count',
		// 'percentile_ranks',
	],
	Date_YYYYMMDD_dash_time: [
		'avg',
		'cardinality',
		'date_histogram',
		'extended_stats',
		'max',
		'min',
		'missing',
		'percentiles',
		'stats',
		'sum',
		'terms',
		'value_count',
		// 'percentile_ranks',
	],
	Date_YYYYMMDD_dash_T_time: [
		'avg',
		'cardinality',
		'date_histogram',
		'extended_stats',
		'max',
		'min',
		'missing',
		'percentiles',
		'stats',
		'sum',
		'terms',
		'value_count',
		// 'percentile_ranks',
	],
	ES_geo_point_obj: [
		'cardinality',
		'geo_bounds',
		'geo_centroid',
		'missing',
		'value_count',
	],
	ES_keyword: [
		'cardinality',
		'terms',
		'value_count',
		// 'string_stats' //disabled until backend upgrade
	],
	'ES_keyword[]': [
		'cardinality',
		'terms',
		'value_count',
		// 'string_stats' //disabled until backend upgrade
	],
	ES_text_w_keyword: [
		'cardinality',
		'terms',
		'value_count',
		// 'string_stats' //disabled until backend upgrade
	],
	'ES_text_w_keyword[]': [
		'cardinality',
		'terms',
		'value_count',
		// 'string_stats' //disabled until backend upgrade
	],
	float: [
		'avg',
		'cardinality',
		'extended_stats',
		'histogram',
		'max',
		'min',
		'missing',
		'percentiles',
		'stats',
		'sum',
		'value_count',
		// 'percentile_ranks',
		// 'weighted_avg',
	],
	integer: [
		'avg',
		'cardinality',
		'extended_stats',
		'histogram',
		'max',
		'min',
		'missing',
		'percentiles',
		'stats',
		'sum',
		'terms',
		'value_count',
		// 'percentile_ranks',
	],
	object: []
}

export function determineESType (field) {
	if (typeof field === 'string') {
		return field;
	}

	if (typeof field === 'object') {
		if ('es_type' in field) {
			return field.es_type;
		}
		if ('data_type' in field) {
			return field.data_type;
		}
		if ('type' in field) {
			return field.type;
		}

		// TODO: Should we throw or simply return 'object'?
		// throw new Error('Bad type specification');
	}

	return 'object';
}

function isKeywordField (fieldType) {
	return fieldType === 'ES_text_w_keyword' || fieldType === 'ES_text_w_keyword[]';
}

function createKeywordFieldQuery (fieldName) {
	return { field: `${fieldName}.keyword` };
}

function defaultAggregationFactory (fieldName, fieldInfo) {
	const fieldType = determineESType(fieldInfo);
	if (isKeywordField(fieldType)) {
		return createKeywordFieldQuery(fieldName);
	}
	return { field: fieldName };
}

const queryFactories = {
	// eslint-disable-next-line no-unused-vars
	weighted_avg: (fieldName, fieldInfo) => {
		return {
			value: { field: fieldName },
			weight: { script: '1'}
		};
	}
}

export function buildAggregation (aggregation, fieldName, fieldInfo) {
	if (aggregation in queryFactories) {
		return queryFactories[aggregation](fieldName, fieldInfo);
	}

	return defaultAggregationFactory(fieldName, fieldInfo);
}

export function constructQuery (schema) {
	const aggs = {};
	for (let f in schema) {
		const fType = determineESType(schema[f]);
		const typeAggs = aggregationsPerType[fType];
		for (let i in typeAggs) {
			const at = typeAggs[i];
			const atName = `${f}_${at}`;
			aggs[atName] = {
				[at]: buildAggregation(at, f, schema[f])
			};
		}
	}

	return {
		size: 0,
		aggs
	};
}
