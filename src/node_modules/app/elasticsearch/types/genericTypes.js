import * as _ from 'lamb';
import {
	containsOneOf,
	isKeyValue,
	isNotNil,
	makeIsIncluded,
	mergeObj,
} from '@svizzle/utils';

// default values
export const defaultKey = '__default';
export const isAppDefaultKey = '__isAppDefault';

export const createDefaultValue = defaultValue => isNotNil(defaultValue)
	? {[defaultKey]: defaultValue}
	: {};
export const createIsAppDefault = isAppDefault => isNotNil(isAppDefault)
	? {[isAppDefaultKey]: isAppDefault}
	: {};

/* types */

export const typeKey = '__type';
export const shapeKey = '__shape';

export const _type = str => (defaultValue, isAppDefault) => ({
	...createDefaultValue(defaultValue),
	...createIsAppDefault(isAppDefault),
	[typeKey]: str,
});
export const is_type = id => isKeyValue([typeKey, id]);
export const get_type = _.getKey(typeKey);

export const _shape = str => (defaultValue, isAppDefault) => ({
	...createDefaultValue(defaultValue),
	...createIsAppDefault(isAppDefault),
	[shapeKey]: str,
});
export const is_shape = id => isKeyValue([shapeKey, id]);
export const get_shape = _.getKey(shapeKey);

// native
export const booleanKey = 'boolean';
export const booleanD = _type(booleanKey);
export const is_boolean = is_type(booleanKey);

export const floatKey = 'float';
export const floatD = _type(floatKey);

export const integerKey = 'integer';
export const integerD = _type(integerKey);

export const stringKey = 'string';
export const stringD = _type(stringKey);

export const boolean = booleanD();
export const float = floatD();
export const integer = integerD();
export const string = stringD();

export const nativeKeys = [
	booleanKey,
	floatKey,
	integerKey,
	stringKey
];

export const is_native = _.pipe([
	_.getKey(typeKey),
	_.curry(_.isIn)(nativeKeys)
]);

// array
const arrayKey = 'array'
export const arrayD = _shape(arrayKey);
export const array = arrayD();
export const arrayOf = (itemsType, defaultValue, isAppDefault) => ({
	...createDefaultValue(defaultValue),
	...createIsAppDefault(isAppDefault),
	...array,
	itemsType,
});
export const is_array = is_shape(arrayKey);
export const getItemsType = _.getKey('itemsType');

// enums
const enumsKey = 'enums';
export const enumsD = _shape(enumsKey);
export const enums = enumsD();
export const enumsOf = (values, defaultValue, isAppDefault) => ({
	...createDefaultValue(defaultValue),
	...createIsAppDefault(isAppDefault),
	...enums,
	values,
});
export const is_enums = is_shape(enumsKey);
export const enumsForKeysOf = _.pipe([
	_.keys,
	type => enumsOf(type, type[0], true)
]);

// object
const objectKey = 'object';
export const objectD = _shape(objectKey);
export const object = objectD();
export const objectOf = mergeObj(object);
export const is_object = is_shape(objectKey);

// xor
const xorKey = 'xor';
export const xorD = _shape(xorKey);
export const xor = xorD();
// export const xorOf = mergeObj(xor);
export const xorOf = obj => ({
	__selection: enumsForKeysOf(obj),
	...obj,
	...xor
});
export const is_xor = is_shape(xorKey);

// union
const unionKey = 'union';
export const unionD = _shape(unionKey);
export const union = unionD();
export const unionOf = (...types) => ({types, ...union});
export const is_union = is_shape(unionKey);

// number
export const number = unionOf(integer, float);
export const is_number = _.pipe([
	get_type,
	makeIsIncluded([floatKey, integerKey])
]);

// extent
const extentKey = 'extent';
export const extentD = _shape(extentKey);
export const extent = {
	...extentD(),
	min: number,
	max:  number,
};
export const extentOf = (fieldType, defaultValue, isAppDefault) => ({
	...createDefaultValue(defaultValue),
	...createIsAppDefault(isAppDefault),
	[shapeKey]: extentKey,
	min: fieldType,
	max: fieldType,
});
export const is_extent = is_shape(extentKey);

// record
export const record = _shape('record')();
export const recordLike = ({keys, values}) => ({
	...record,
	values,
	_keys: keys && is_enums(keys) || string,
});

// constant
export const constant = ({type, shape, value}) => ({
	..._shape('constant'),
	value,
	...type ? {[typeKey]: type} : {},
	...shape ? {[shapeKey]: shape} : {},
});

// intWithUnit
export const intWithUnitKey = 'intWithUnit';
export const intWithUnitD = _shape(intWithUnitKey);
export const intWithUnitOf = (units, defaultUnit) => ({
	...intWithUnitD(),
	value: integerD(1),
	unit: enumsOf(units, defaultUnit)
});
export const is_intWithUnit = is_shape(intWithUnitKey);

// numberInExtent
export const numberWithinExtent = {
	..._shape('numberWithinExtent'),
	...number,
	min: number,
	max:  number,
};
export const numberWithin = ([min, max]) => ({
	...numberWithinExtent,
	min,
	max,
});

/* utils */

export const isTyped = _.anyOf([_.hasKey(typeKey), _.hasKey(shapeKey)]);
export const notTyped = _.not(isTyped);

export const hasDefault = _.hasKey(defaultKey);
export const hasNoDefault = _.not(hasDefault);
export const hasESdefault =
	obj => isNotNil(obj[defaultKey]) && !obj.__isAppDefault;

export const getDefault = _.getKey(defaultKey);

const isLabelOf = _.pipe([
	_.list,
	_.pluck(typeKey),
	_.apply(containsOneOf)
]);

const isNumberLabel = isLabelOf(integer, float);

// arg: type key
export const numberOrString = fieldTypeKey =>
	_type(isNumberLabel(fieldTypeKey) ? fieldTypeKey : 'string')();

// arg: type
export const numberOrString2 = fieldType =>
	is_number(fieldType) && number || string;

export const objectifyValues = _.mapValuesWith(_.when(notTyped, objectOf));

export const extractBaseType = _.getKey(typeKey);
