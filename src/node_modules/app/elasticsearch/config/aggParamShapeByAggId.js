const metricFieldParams = type => ({
	field: 'string',
	missing: [
		['integer', 'float'].includes(type)
			? type
			: 'string',
		'undefined'
	]
});

const sortOptions = {
	_key: ['"asc"', '"desc"', 'undefined'],
	_count: ['"asc"', '"desc"', 'undefined']
};

const paramsByMetricAgg = {
	avg: metricFieldParams,
	boxplot: type => ({
		...metricFieldParams(type),
		compression: ['integer', 'undefined'],
	}),
	cardinality: type => ({
		...metricFieldParams(type),
		precision_threshold: ['integer', 'undefined'],
	}),
	extended_stats: type => ({
		...metricFieldParams(type),
		sigma: ['float', 'undefined'],
	}),
	geo_bounds: type => ({
		...metricFieldParams(type),
		wrap_longitude: ['boolean', 'undefined'],
	}),
	geo_centroid: metricFieldParams,
	max: metricFieldParams,
	median_absolute_deviation: type => ({
		...metricFieldParams(type),
		compresison: ['integer', 'undefined'],
	}),
	min: metricFieldParams,
	percentile_ranks: type => ({
		...metricFieldParams(type),
		values: 'float[]',
		keyed: ['boolean', 'undefined'],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	percentiles: type => ({
		...metricFieldParams(type),
		percents: ['float[]', 'undefined'],
		keyed: ['boolean', 'undefined'],
		tdigest: [
			{
				compression: 'integer'
			},
			'undefined'
		],
		hdr: [
			{
				number_of_significant_value_digits: 'integer'
			},
			'undefined'
		]
	}),
	scripted_metric: {
		init_script: 'Script',
		map_script: 'Script',
		combine_script: 'Script',
		reduce_script: 'Script',
	},
	stats: metricFieldParams,
	string_stats: type => ({
		...metricFieldParams(type),
		show_distribution: ['boolean', 'undefined']
	}),
	sum: metricFieldParams,
	t_test: type => ({
		a: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		b: {
			...metricFieldParams(type),
			filter: ['json', 'undefined']
		},
		type: ['"paired"', '"homoscedastic"', '"heteroscedastic"']
	}),
	top_hits: {
		from: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		sort: [sortOptions, 'undefined'],
		_source: ['string', 'string[]']
	},
	top_metrics: type => ({
		metric: [
			metricFieldParams(type),
			{__array: metricFieldParams(type)}
		],
		sort: sortOptions,
		size: ['integer', 'undefined']
	}),
	value_count: metricFieldParams,
	weighted_avg: type => ({
		value: {
			...metricFieldParams(type)
		},
		weight: {
			...metricFieldParams(type)
		},
		format: ['json', 'undefined'],
		value_type: ['json', 'undefined']
	})
};

const paramsByBucketingAgg = {
	adjacency_matrix: {
		filters: {
			__record: 'string',
			__type: {
				__record: 'field',
				__type: 'string[]'
			}
		},
		separator: 'string'
	},
	auto_date_histogram: type => ({
		...metricFieldParams(type),
		buckets: ['integer', 'undefined'],
		format: ['string', 'undefined'],
		time_zone: ['string', 'undefined'],
		minimum_inteval: ['string', 'undefined'],
	}),
	children: {
		type: 'string'
	},
	composite: type => ({
		sources: {
			__record: 'string',
			__type: {
				...metricFieldParams(type),
				size: 'integer',
				order: [sortOptions, 'undefined']
			}
		},
		size: ['integer', 'undefined'],
		after: 'json'
	}),
	date_histogram: type => ({
		...metricFieldParams(type),
		__interval: {
			__type: ['"interval"', '"calendar_interval"', '"fixed_interval"'],
			interval: {
				__units: ['ms', 's', 'm', 'h', 'd', 'w', 'M', 'q', 'y']
			},
			calendar_interval: {
				__units: ['m', 'h', 'd', 'w', 'M', 'w', 'q', 'y']
			},
			fixed_interval: {
				__units: ['ms', 's', 'm', 'h', 'd']
			}
		},
		time_zone: 'string',
		order: [sortOptions, 'undefined'],
		min_doc_count: ['integer', 'undefined']
	}),
	date_range: type => ({
		...metricFieldParams(type),
		format: 'string',
		ranges: {
			__array: {
				key: ['string', 'undefined'],
				from: ['string', 'undefined'],
				to: ['string', 'undefined']
			}
		},
		keyed: ['boolean', 'undefined']
	}),
	diversified_sampler: type => ({
		...metricFieldParams(type),
		execution_hint: [
			'"map"',
			'"global_ordinals"',
			'"bytes_hash"',
			'undefined'
		],
		max_docs_per_value: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	}),
	filter: {
		filter: 'json'
	},
	filters: {
		other_bucket: ['boolean', 'undefined'],
		other_bucket_key: ['string', 'undefined'],
		filters: {__array: 'json'},
	},
	geo_distance: type => ({
		...metricFieldParams(type),
		origin: 'string',
		unit: ['"m"', '"mi"', '"in"', '"yd"', '"km"', '"cm"', '"mm"'],
		ranges: {__array: 'json'},
		keyed: ['boolean', 'undefined'],
		distance_type: ['"arc"', '"plane"']
	}),
	geohash_grid: {
		field: 'field',
		precision: ['integer', 'undefined'],
		size: ['integer', 'undefined'],
		shard_size: ['integer', 'undefined']
	},
	global: {},
	histogram: type => ({
		...metricFieldParams(type),
		interval: type,
		offset: [type, 'undefined'],
		min_doc_count: ['integer', 'undefined'],
		keyed: ['boolean', 'undefined'],
		order: [sortOptions, 'undefined'],
		extended_bounds: [
			{
				__legacyName: `MinMax<${type}>`,
				min: type,
				max: type
			},
			'undefined'
		]
	}),
	ip_range: type => ({
		...metricFieldParams(type)
	}),
	missing: metricFieldParams,
	nested: {
		path: 'string'
	},
	range: type => ({
		...metricFieldParams(type),
		ranges: {__array: 'json'}
	}),
	rare_terms: type => ({
		...metricFieldParams(type),
		max_doc_count: ['integer', 'undefined'],
		precision: ['float', 'undefined'],
		include: ['string[]', 'undefined'],
		exclude: ['string[]', 'undefined'],
	}),
	reverse_nested: {
		path: ['string', 'undefined']
	},
	sampler: {
		shard_size: ['integer', 'undefined']
	},
	significant_terms: type => ({
		...metricFieldParams(type),
		min_doc_count: ['integer', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		jlh: ['Existence', 'undefined'],
		mutual_information: [
			{
				include_negatives: ['boolean', 'undefined'],
				background_is_superset: ['boolean', 'undefined']
			}
		],
		chi_square: ['Existence', 'undefined'],
		gnd: ['Existence', 'undefined'],
		percentage: ['Existence', 'undefined'],
	}),
	significant_text: type => ({
		...metricFieldParams(type),
		filter_duplicate_text: ['boolean', 'undefined'],
		background_filter: [
			{
				term: {
					content: 'string'
				}
			},
			'undefined'
		],
		source_fields: [
			{__array: 'string'},
			'undefined'
		]
	}),
	terms: type => ({
		...metricFieldParams(type),
		size: 'integer',
		collect_mode: [
			'"depth_first"',
			'"breadth_first"'
		],
		execution_hint: [
			'"global_ordinals"',
			'"map"'
		],
		order: [
			sortOptions,
			'undefined'
		]
	})
};

/*
const paramsByMatrixAgg = {
	matrix_stats: {
		fields: {__array: 'fields'},
		missing: [

			,
			'undefined'
		]
	}
};
*/

export const aggParamShapeByAggId = {
	...paramsByMetricAgg,
	...paramsByBucketingAgg,
	// ...paramsByMatrixAgg
}
