import * as _ from 'lamb';

import aggsIdByFieldType from 'app/elasticsearch/config/aggsIdByFieldType';
import {
	baseAggFor,
	dateHistogramAggFor,
	histogramAggFor,
	termsAggFor,
} from 'app/elasticsearch/types/esTypes/aggs';
import {
	optional,
	script,
	sortOptions,
} from 'app/elasticsearch/types/esTypes/params';
import {
	arrayOf,
	boolean,
	booleanD,
	enumsOf,
	float,
	floatD,
	integer,
	integerD,
	object,
	objectD,
	objectifyValues,
	objectOf,
	recordLike,
	string,
	stringD,
	unionOf,
	xorOf,
} from 'app/elasticsearch/types/genericTypes';

/* params */

const staticParamsShapeByMetricAgg = {
	scripted_metric: {
		init_script: script,
		map_script: script,
		combine_script: script,
		reduce_script: script,
	},
	top_hits: {
		_source: unionOf(string, arrayOf(string)),
		from: optional(integer),
		size: optional(integerD(3)),
		sort: optional(sortOptions),
	},
};

const makeParamsShapeByMetricAgg = fieldType => ({
	avg: baseAggFor(fieldType),
	boxplot: {
		...baseAggFor(fieldType),
		compression: optional(integer),
	},
	cardinality: {
		...baseAggFor(fieldType),
		precision_threshold: optional(integerD(3000)),
	},
	extended_stats: {
		...baseAggFor(fieldType),
		sigma: optional(floatD(2)),
	},
	geo_bounds: {
		...baseAggFor(fieldType),
		wrap_longitude: optional(booleanD(true)),
	},
	geo_centroid: baseAggFor(fieldType),
	max: baseAggFor(fieldType),
	median_absolute_deviation: {
		...baseAggFor(fieldType),
		compression: optional(integerD(100)),
	},
	min: baseAggFor(fieldType),
	percentile_ranks: {
		...baseAggFor(fieldType),
		hdr: optional(objectOf({
			number_of_significant_value_digits: integer
		})),
		keyed: optional(booleanD(true)),
		values: arrayOf(float),
	},
	percentiles: {
		...baseAggFor(fieldType),
		hdr: optional(objectOf({
			number_of_significant_value_digits: integer
		})),
		keyed: optional(booleanD(true)),
		percents: optional(arrayOf(float, [1, 5, 25, 50, 75, 95, 99])),
		tdigest: optional(objectOf({
			compression: integerD(100)
		})),
	},
	stats: baseAggFor(fieldType),
	string_stats: {
		...baseAggFor(fieldType),
		show_distribution: optional(boolean)
	},
	sum: baseAggFor(fieldType),
	t_test: {
		a: objectOf({
			...baseAggFor(fieldType),
			filter: optional(object)
		}),
		b: objectOf({
			...baseAggFor(fieldType),
			filter: optional(object)
		}),
		type: enumsOf(['paired', 'homoscedastic', 'heteroscedastic'])
	},
	top_metrics: {
		metric: unionOf(
			baseAggFor(fieldType),
			arrayOf(objectOf(baseAggFor(fieldType)))
		),
		sort: sortOptions,
		size: optional(integer)
	},
	value_count: baseAggFor(fieldType),
	weighted_avg: {
		format: optional(object),
		value_type: optional(object),
		value: objectOf(baseAggFor(fieldType)),
		weight: objectOf(baseAggFor(fieldType)),
	},
});

const staticParamsShapeByBucketingAgg = {
	adjacency_matrix: {
		filters: recordLike({
			values: recordLike({
				keys: enumsOf(['aggId']),
				values: recordLike({
					keys: enumsOf(['field']),
					values: arrayOf(string)
				})
			})
		}),
		separator: string
	},
	children: {
		type: string
	},
	filter: {
		filter: object
	},
	filters: {
		other_bucket: optional(booleanD(false, true)), // TODO not explicitly stated in the docs, must test
		other_bucket_key: optional(stringD('_other_')),
		filters: arrayOf(object)
	},
	geohash_grid: {
		field: string,
		precision: optional(integerD(3, true)), // [2]
		shard_size: optional(integer), // ES default is -> max(10,(size x number-of-shards)) buckets from each shard.
		size: optional(integerD(10000)),
	},
	global: object,
	nested: {
		path: string
	},
	reverse_nested: {
		path: optional(stringD(''))
	},
	sampler: {
		shard_size: optional(integerD(100))
	},
};

const makeParamsShapeByBucketingAgg = fieldType => ({
	auto_date_histogram: {
		...baseAggFor(fieldType),
		buckets: optional(integerD(10)),
		format: optional(stringD('YYYYMMdd', true)),
		minimum_inteval: optional(integer),
		time_zone: optional(stringD('UTC')),
	},
	// composite: {
	// 	after: optional(object),
	// 	size: optional(integer),
	// 	// [1]
	// 	sources: arrayOf(unionOf([
	// 		objectOf({
	// 			...termsAggFor(fieldType),
	// 			order: optional(sortOptions)
	// 		}),
	// 		objectOf({
	// 			...histogramAggFor(fieldType),
	// 			order: optional(sortOptions)
	// 		}),
	// 		objectOf({
	// 			...dateHistogramAggFor(fieldType),
	// 			order: optional(sortOptions)
	// 		}),
	// 	])),
	// },
	date_histogram: dateHistogramAggFor(fieldType),
	date_range: {
		...baseAggFor(fieldType),
		format: stringD('YYYYMMdd', true),
		keyed: optional(booleanD(false)),
		ranges: arrayOf(objectOf({
			key: optional(string),
			from: optional(string),
			to: optional(string),
		})),
	},
	diversified_sampler: {
		...baseAggFor(fieldType),
		execution_hint: optional(
			enumsOf(['map', 'global_ordinals', 'bytes_hash'], 'global_ordinals')
		),
		max_docs_per_value: optional(integerD(1)),
		shard_size: optional(integerD(100)),
	},
	geo_distance: {
		...baseAggFor(fieldType),
		distance_type: enumsOf(['arc', 'plane'], 'arc'),
		keyed: optional(booleanD(false)),
		origin: string,
		ranges: arrayOf(object),
		unit: enumsOf(['m', 'mi', 'in', 'yd', 'km', 'cm', 'mm'], 'm'),
	},
	histogram: histogramAggFor(fieldType),
	ip_range: baseAggFor(fieldType),
	missing: baseAggFor(fieldType),
	range: {
		...baseAggFor(fieldType),
		ranges: arrayOf(object)
	},
	rare_terms: {
		...baseAggFor(fieldType),
		exclude: optional(arrayOf(string)),
		include: optional(arrayOf(string)),
		max_doc_count: optional(integer),
		precision: optional(floatD(0.01)),
	},
	significant_terms: {
		...baseAggFor(fieldType),
		background_filter: optional(
			objectOf({
				term: objectOf({
					content: string
				})
			})
		),
		min_doc_count: optional(integerD(1, true)),
		mutual_information: optional(
			objectOf({
				include_negatives: optional(boolean),
				background_is_superset: optional(boolean)
			})
		),
		__algorithms: optional(xorOf({
			chi_square: optional(objectD({})),
			gnd: optional(objectD({})),
			jlh: optional(objectD({})),
			percentage: optional(objectD({})),
		}))
	},
	significant_text: {
		...baseAggFor(fieldType),
		background_filter: optional(objectOf({
			term: objectOf({
				content: string
			})
		})),
		filter_duplicate_text: optional(booleanD(false)),
		source_fields: optional(arrayOf(string))
	},
	terms: termsAggFor(fieldType),
});

/*
const staticParamsShapeByMatrixAgg = {
	matrix_stats: {
		fields: enumsOf(['fields']),
		missing: optional()
	}
};
*/

const makeAggParamShapeByAggId = fieldType => objectifyValues({
	...staticParamsShapeByMetricAgg,
	...makeParamsShapeByMetricAgg(fieldType),
	...staticParamsShapeByBucketingAgg,
	...makeParamsShapeByBucketingAgg(fieldType),
	// ...staticParamsShapeByMatrixAgg
});

const aggParamsShapeByFieldtypeByAggId = _.mapValues(
	aggsIdByFieldType,
	(...[,fieldType]) => makeAggParamShapeByAggId(fieldType)
);

export default aggParamsShapeByFieldtypeByAggId;

/*
[1]
sources: [
	{ "product": { "terms" : { "field": "product" } } },
	{ "histo": { "histogram" : { "field": "price", "interval": 5 } } }
	{ "date": { "date_histogram" : { "field": "timestamp", "calendar_interval": "1d" } } }
]

[2]
using `5` causes: `Trying to create too many buckets. Must be less than or equal to: [10000] but was [15010]. This limit can be set by changing the [search.max_buckets] cluster level setting.`
*/
